---
title: "Lesson_3"
author: "Chen"
date: "2024-09-09"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>


<!-- tutorial options and checking options - TODO set params -->
```{r setup, include=FALSE}
library(learnr)

tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)
knitr::opts_chunk$set(error = TRUE)
```

## וקטורים
וקטורים הם משתנים הפשוטים ביותר שמכילים יותר מערך אחד. למשל אם נרצה לאמוד ערך אחד עבור כל תלמיד בכיתה ונרצה לאכסן את כל המידע של הכיתה במשתנה אחד.
  בR מגדירים וקטור על ידי שימוש ב`c()`. כל האיברים שיכנסו לוקטור יוגדרו בתוך הסוגריים ויופרדו בפסיק.   לדוגמה:

```{r}
# דוגמה להגדרת וקטור
c(1, 2, 3, 4)

# גם וקטורים ניתן להגדיר כמשתנים
vector <- c(1, 2, 3, 4)
# אם נרצה להציגו
vector

# ניתן גם להגדיר כמה משתנים ואז לאסוף אותם בוקטור
a = 1
b = 2
c = 3
d = 4
vector_2 <- c(a, b, c, d)
vector_2

# האם התוצאה באמת זהה?
# בואו נשתמש בהשוואה 
vector == vector_2

```
שתי הערות חשובות:  
1. לאחר שהגדרנו את הוקטור השני, שמורכב מ4 משתנים שונים, הוא מכיל רק את הערכים ושינוי של המשתנים המקוריים לא יוביל אוטומטית לשינוי של הוקטור   
2. התוצר של ההשוואה ברמת הוקטור הוא בעצם וקטור נוסף אשר מכיל ערכים לוגיים בכל איבריו. אורך כל הוקטורים חייב להיות זהה כדי לבצע את ההשוואה הזאת בצורה נכונה.

```{r vec_basic_question, echo = FALSE}
question(" מה לדעתכם הייתה התוצאה עבור ההשוואה הבאה:  
           vector_3 <- c(b, b, c, d)  
         vector == vector_3",
         answer("התוכנה הייתה מחזירה שגיאה",  message ="לא הייתה אמורה להתקבל שגיאה במקרה זה. רק במקרה שהינו מוסיפים עוד איבר לוקטור החדש, ההשוואה בין 5 ל4 ערכים לא הייתה מתאפשרת והיינו מקבלים שגיאה. "),
         answer("FALSE", message = "האמנם הוקטורים כבר לא זהים אבל שימו לב שהתוכנה תחזיר תשובה בנפרד לכל ערך בוקטור."),
         answer("[TRUE, FALSE, TRUE, TRUE]", message = "קרוב מאוד! אבל שימו לב לסדר, הערך הראשון הוא שהשתנה ולא השני. "),
         answer("[FALSE, TRUE, TRUE, TRUE]",correct =TRUE, message = "כיוון ששינינו את הערכך הראשון הוא כבר לא יהיה זהה ולכן האיבר הראשון בתוצאה ישתנה. שאר האיברים לא השתנו ולכן ישארו כמו בדוגמה"),
         allow_retry = TRUE
)
```

### שימו בנתונים
כעת נחזור לדוגמה שלנו מהשיעור הקודם על שאלון האישיות. כעת נוכל לקבל נתונים שונים עבור יותר ממשתתף אחד. כמו שלרוב נרצה לעשות במחקר.
קבוצת חברים מסוימת ענתה על השאלון שלנו, להלן סידור של נתוניהם בוקטורים:

```{r}
# וקטור השמות של המשתתפים - שימו לב! וקטור יכול להכיל גם מחרוזות ולא רק מספרים
c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# שימו לב, כדי שנשמור את הנתונים עלינו להגדיר משתנה
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# עכשיו נוכל לקבל גם מידע על ציונהם של הקבוצה בתכונה "מוסר עבודה" - C
ave_C <- c(6, 4, 2, 3, 7, 1)
```

`תרגיל`  
הגדירו וקטור נוסף של ציוני הקבוצה בתכונה של "מוחצנות". הגדירו וקטור חדש שנקרא ave_E ובו כל משתתף קיבל ציון של 3.

```{r def_vec_ex, exercise=TRUE, exercise.eval = FALSE}

  
```

```{r def_vec_ex-solution}

ave_E <- c(3, 3, 3, 3, 3, 3)

```

### פעולות פשוטות על וקטורים
כמו שניתן לבצע פעולות השוואה עם וקטורים, ניתן גם להשתמש בכל אופרטור שיצא לנו להכיר. אבל חשוב לשים לב בין אילו וקטורים ניתן לבצע פעולות.  
מומלץ לבצע השוואות ופעולות בין שני וקטורים בעלי אורך זהה `או` בין ערך בודד לוקטור.  
מה יקרה אם נשווה בין וקטורים בעלי אורכים שונים? צריך לעשות זאת בזהירות כיוון שיש כמה אפשרויות. אם נשווה בין וקטור בעל 6 ערכים לוקטור בעל 5 ערכים נקבל שגיאה. אבל אם נשווה בין וקטור בעל 6 איברים ולקטור בעל כמות איברים שמתחלקת ב6 (למשל 12) או כמות איברים ש6 מתחלק בה (למשל 3 או 2) התוכנה תכפיל את הוקטור הקצר יותר ותבצע השוואה. 
למשל:  

```{r}
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

# אפשר לחבר וקטורים באותו האורך
ave_C + ave_E

# אפשר גם לכפול בינהם
ave_C * ave_E

# עוד...

# עכשיו ננסה להחסיר ערך בודד מכל הערכים בוקטור
ave_C-1 

# או להעלות את הוקטור בחזקת 3
ave_C ^3

# ננסה להשוות לוקטור חדש עם 3 איברים
v = c(1, 2, 3)
ave_E == v

# ועכשיו לוקטור עם 5 איברים
v = c(1,2,3,4,5)
ave_E == v

```


נתונה לכם שורת הקוד הבאה:
ave_E-c(1, 2)
```{r vec_op_question, echo = FALSE}
question("מה יקרה אם ננסה להריץ את השורה הבאה",
         answer("התוכנה הייתה מחזירה שגיאה",  message =" כאשר משווים שני וקטורים בעלי אורכים שונים יש סכנה שנקבל שגיאה, אבל במקרה הזה האורך של הוקטור המקורי מתחלק ב2"),
         answer("FALSE", message = "שורת הקוד מבצעת חיסור ולא השוואה, גם אם הייתה מתבצעת השוואה היינו מקבלים ערך אחד עבור כל איבר בוקטור הארוך יותר"),
         answer("[FALSE, FALSE, FALSE, FALSE, FALSE, FALSE]", message = "קרוב מאוד! אבל שימו לב ששורת הקוד לא מבצעת השוואה אלא חיסור."),
         answer("2 1 2 1 2 1",correct =TRUE, message = "נכון, התוכנה תכפיל את הוקטור הקצר פי 3 ותבצע חיסור כאילו מדובר בוקטורים עם אותו אורך"),
         allow_retry = TRUE
)
```

## אינדקסים
כאשר אנחנו נבצע את המעבר ממשתנה בעל ערך יחיד למשתנה רב ערכים (הוקטור) אנחנו נצטרך להשתמש באינדקסים כדי לגשת לערכים בודדים שנמצאים בתוך הוקטור.
בשפת התכנות R כל ערך מקבל מספר, כאשר הערך הראשון בתוך הוקטור הוא באינדקס 1 (שימו לב, אולי זה נראה לכם מאוד אינטואטיבי שמתחילים לספור ב1, אבל אם אתם מכירים שפות תכנות אחרות אולי אתם רגילים ש-0 הוא האינדקס הראשון אז חשוב לקחת בחשבון את השינוי). האינדקס האחרון הוא תמיד מספר האיברים שקיימים בוקטור. 

האינדקסים הם בעצם גורם שיכול לעזור לנו לאחד בין שני וקטורים שונים. כמו בדוגמה הראשונה שלנו, ראינו שיש וקטור אחד עם שמות המשתתפים ווקטור אחר עם דירוגיהם בשאלון. 
כעת נלמד איך לגשת לערכים שונים באמצעות אינדקס.

כעת ננסה לשלוף את הערכים של המשתתף השלישי במחקר:
```{r}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

names[3]
ave_C[3]
ave_E[3]
```
דוגמה נחמדה, קיבלנו את הערכים של ג'ואי 
עכשיו נלמד גם איך לשלוף כמה ערכים לפי אינדקס.

```{r}
# אם מעוניינים בטווח של ערכים רציפים ניתן גם להשתמש באפשרות זאת:
ave_C[1:3]
# אם אנחנו רוצים דווקא ערכים לא רציפים אפשר להגדיר וקטור נפרד עם הערכים שרצוניים לנו:
ind <- c(1,3,6)
ave_C[ind]
```
  
אבל מה נעשה אם יבקשו מאיתנו לוודא מה התוצאות של רוס? כרגע קל לנו לראות שהוא ראשון ברשימה, אבל אם היו 1000 משתתפים כבר היינו צריכים לפנות לאסטרטגיה אחרת.   
נוכל פשוט לפנות להשוואה בין וקטורים  

```{r}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

names=="Ross"

# עכשיו יש לנו וקטור שמסמן לנו איפה בוקטור השמות מתקיים התנאי. אפשר להשתמש בוקטור הזה כאינדקס כך:
ave_C[names=="Ross"]
ave_E[names=="Ross"]
```
שימו לב, הערכים ששבהם התנאי מתקיים וקיבלו את הערך TRUE בוקטור של תוצאת ההשוואה הודפסו.

  
  `תרגיל`
בנוסף לנתונים הקודמים נתון לכם וקטור חדש אשר מציין את המגדר של כל משתתף במחקר.
קודם כל הציגו את תוצאותיהן של כל הנשים בתכונה C.  
לאחר מכן הדפיסו את כל השמות של המשתתפים שערך C שלהם הוא גבוה מ3.

```{r index_ex, exercise=TRUE, exercise.eval = FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)

# הציגו את תוצאות הנשים כאן:

# הציגו את השמות שקיבלו ערך מעל 3 כאן:

```

```{r index_ex-solution}
# הציגו את תוצאות הנשים כאן:
ave_C[gender=="F"]
# הציגו את השמות שקיבלו ערך מעל 3 כאן:
names[ave_C>3]

```

```{r index_ex-check}
"במקרה זה היו מספר ערכים שהיו זהים להשוואות שהתבקשתם לייצר לכן התשובה היא וקטור בעל איברים ככמות הערכים שעונים על ההשוואה. 
"
```

### עריכת וקטורים
גם לכם הוקטור של התכונה E נראה מוזר? מי שמכיר את החברים בוודאי יודע שלא לכולם יש רמת מוחצנות זהה.   
בואו נשנה את רמת המוחצנות של ג'ואי ל6.
```{r}
ave_E <- c(3, 3, 3, 3, 3, 3)
# לפי הסדר המקורי נרצה לשנות את הערך השלישי
ave_E[3] <- 6
# בואו נראה מה יצא
ave_E

```
בעצם יש לנו דרך טובה יותר לשנות ערכים!

`תרגיל` 
עכשיו שנו אתם את שאר הערכים שאינם נכונים. שנו את הערך של פיבי ל5 ואת הערך של רוס וצ'נדלר ל1. 

```{r ed_vec_ex, exercise=TRUE, exercise.eval = FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:

```

```{r ed_vec_ex-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:
ave_E[names=="Phoebe"]<-5
ave_E[names=="Ross"|names=="Chandler"]<-1



```


## פונקציות בסיסיות
אז עכשיו שהגענו שכבר אספנו לא מעט נתונים על החברים אפשר להתחיל להסתכל על התוצאות שלהם ברמת הקבוצה. 
בשיעור הקודם למדנו איך לבצע חיבור וחיסור למשל. ונוכל להתחיל לחשב את סכום ציוניהם של החברים בתכונה E כך:
```{r}
# נחזור לוקטור שיצרנו בתרגיל הקודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# נחשב את הסכום הכולל באמצעות פעולת חיבור
ave_E_sum <- ave_E[1] + ave_E[2] + ave_E[3] + ave_E[4] + ave_E[5] + ave_E[6]

ave_E_sum
```

קצת מתיש לא?
כעת נלמד איך לבצע מספר פעולות פשוטות על וקטורים
הדרך שהכרנו עד עכשיו תדרוש מאיתנו לבודד איבר איבר ולחבר בניהם באמצעות +. אך שפת התכנות יצרה עבורינו _פונקציות_ אשר יכולות לבצע פעולות שכאלה בצורה יעילה
למשל הפונקציה `sum()`

```{r}
# נחזור לוקטור שיצרנו קודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# ועכשיו באמצעות הפונקציה sum()
ave_E_sum <- sum(ave_E)
ave_E_sum
```
התוצאה שהתקבלה כמובן זהה, אבל כמות העבודה שונה מהותית. 


פונקציה נוספת שיכולה להיות שימושית היא הפונקציה `length()`. כמו שיכולתם לנחש, פונקציה זאת מחשבת את האורך של הוקטור, או יותר נכון את כמות האיברים שלו.
אם נריץ את שורת הקוד הבאה:  
length(ave_E_sum)  

```{r vector_question, echo = FALSE}
question(" מה תהיה התוצאה?",
         answer("1", correct = TRUE, message ="נכוןת במשתנה בו חישבנו את הסכום יש ערך אחד בלבד"),
         answer("19", message = "זאת תהיה התוצאה של הפונקציה שמחשבת את סכום הוקטור ולא האורך שלו"),
         answer("FALSE", message = "זהו ערך לוגי, אורך הוקטור יהיה מספר"),
         answer("6", message = "קרוב אבל לא בדיוק! בוקטור המקורי של הנתונים שלנו יש 6 איברים."),
         allow_retry = TRUE
)
```

`תרגיל`
עכשיו חשבו את ממוצע של החברים בתכונה E באמצעות הפונקציה sum והפונקציה length.
  
```{r mean_ex, exercise=TRUE, exercise.eval = FALSE}
ave_E <- c(1, 1, 6, 3, 3, 5)
# חשבו את הממוצע כאן:
total_ave_E <-
```

```{r mean_ex-solution}
ave_E <- c(1, 1, 6, 3, 3, 5)
# ערכו את הוקטור כאן:
total_ave_E <- sum(ave_E)/length(ave_E)

```

האמנם זה היה הרבה יותר קל מאשר החישוב באמצות אופרטורים, אבל יש דרך אפילו יותר קלה. הפונקציה:
`mean()` 

```{r}
# ננסה לחזור על התרגיל
ave_E <- c(1, 1, 6, 3, 3, 5)
# נבצע את החישוב כך:
total_ave_E <- mean(ave_E)
total_ave_E
```

### פונקציות שכדאי להכיר
`var` - פונקציה המחשבת את השונות (מדד לסטיה מהממוצע בריבוע)  
`sd` - מחשב את סטיית התקן (מדד לסטיה הממוצעת מהממוצע)  
`min` - מחזיר לנו את הערך המינימלי בוקטור  
`max` - מחזיר לנו את הערך המקסימלי בוקטור  
`unique` - מחזיר לנו וקטור חדש ובו רק הערכים הייחודיים שמופיעים בוקטור  
`sort` - פונקציה המחזירה לנו וקטור חדש, עם כל הערכים שקיימים בוקטור המקורי רק בסדר עולה (אם מדובר במספרים) או לפי הא-ב אם מדובר במחרוזות.  


### סוגי משתנים למתקדמים
עכשיו, נכיר עוד סוג אחד של משתנה שלא הכרנו בשיעור הקודם `הפקטור - factor`.
הפקטור הוא וקטור שמזכיר קצת וקטור לוגית מהבחינה שהוא יכול לקבל רק ערכים מסויימים, אך הוא לא מוגבל לנכון ולא נכון אלא יכול לקבל כל סוג ערכים שנרצה.
למשל הוקטור שהכיל את המגדר של החברים, הוא וקטור עם ערכים שאנחנו הגדרנו אבל הוא יכול לקבל רק סט מסוים של ערכים (גבר או אישה).  
כעת נראה דוגמה להגדרה של פקטור:

```{r}
# כדי לסווג משתנה כפקטור נשתמש בפוקנקציה 
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# הפונקציה הבאה תוכל להראות לנו איזה ערכים וקטור כזה יכול לקבל:
levels(gender)

```

שימו לב! כעת הוקטור מוגבל ולא ניתן להוסיף לו ערכים שלא היו קיימים בוקטור המקורי.   
למשל, פיבי ביקשה שלא יציינו עבורה את משתנה זה. בכל מחקר צריך לאפשר למשתתפים להרגיש בנוח. לכן נרצה להוסיף רמה שלישית: Unknown  או בקיצור U

```{r}
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# ננסה להכניס את הערך U
gender[6] <- "U"

# התוכנה מעלה לנו שגיאה. 
# לא ניתן לבצע את הפעולה הזאת! קודם כל הרמות של המשתנה צריכות לכלול את האופציה הזאת. נערוך אותן כך:
levels(gender) <- c("M", "F", "U")

# ננסה שוב
gender[6] <- "U"

# ועכשיו נציג
gender

# אם נחליט שהשימוש באותיות לא נוח אפשר פשוט לשנות את השמות של הרמות השונות כך:
levels(gender) <- c("Female", "Male", "Unknown")

# דרך מאוד יעילה לערוך שינוים!
gender
```


בהקשר זה יש עוד שני סוג וקטורים שלפעמים נרצה לעבור בינהם. לכן כדאי להכיר את הפונקציות:

`as.numeric()` - תהפוך את הפורמט של הוקטור כולו למספרי. התוצאה תהיה int או float בהתרם למה שקיים בוקטור. פונקציה זאת שימושית במיוחד במקרים שיש ספרות בפורמט של טקסט ורוצים לבצע עליו פעולות מספריות.   

`as.character()` - תהפוך את הפורמט כולו לטקסט (character הן בעצם אותיות או תוים, אבני הבנין של המחרוזות). פונקציה זאת שימושית אם רוצים להשתמש במספרים בפורמט טקסט או לאחד בוקטור אחד טקסט ומספרים. כיוון שלאותיות אין משמעות מספרית, כאשר יהיה לנו וקטור שכולל גם מחרוזות הפורמט של הוקטור לא יכול להיות מספרי.

ואחרונה חביבה:
`class()` - פונקציה שתדפיס לנו לאיזה סוג משתייך הוקטור. הכניסו את שם המשתנה בסוגריים והפונקציה תדפיס לכם את התשובה.


## תרגיל מסכם
נתונים לשאלות:  
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")  
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))  
employment <- c("yes", "yes", "No", "Yes", "No", "no")  
income <- c(75, 100, 20, 50, 80, 15)  

תשובות לשאלונים בכל המימדים:  
ave_E <- c(1, 1, 6, 3, 3, 5)  
ave_C <- c(6, 4, 2, 3, 7, 1)  
ave_A <- c(4, 4, 5, 7, 3, 6)  
ave_N <- c(5, 7, 2, 3, 7, 1)  
ave_O <- c(2, 3, 6, 3, 1, 7)  

שימו לב, זה זמן טוב להתחיל לתרגל את הרעיון של סביבת עבודה. בתרגילים הבאים כבר נתחיל לפנות אתכם החוצה מן הלומדה אל התוכנה עצמה. אבל לפני שנעשה זאת נכיר לעומק את המושג של "סביבת עבודה". כלומר, כל פעם שאנחנו מריצים שורת קוד שכוללת הגדרה של משתנים המשתנים קיימים לנו בסביבה ואנחנו יכולים להשתמש בהם מבלי להגדיר אותם מחדש. בתרגילים מטה, כל תיבת פתרון של שאלה מהווה סביבת עבודה נפרדת. לכן עליכם להבין איזה משתנים תצטרכו לפתרון השאלה והעתיקו אותם.  
  
`שאלה 1 `  
לאחר ההשתתפות במחקר החברים ביקשו לקבל חוות דעת. החברים מבקשים לדעת מה היא התכונה הכי דומיננטית בחבורה.   
כלומר, אם הייתם מחשבים את הממוצע של החברים בכל תכנוה בנפרד מה היא התכונה בעלת הערך הגבוה ביותר?
```{r final_ex_1, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_1-solution}
# נתונים:
ave_E <- c(1, 1, 6, 3, 3, 5)
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_A <- c(4, 4, 5, 7, 3, 6)
ave_N <- c(5, 7, 2, 3, 7, 1)
ave_O <- c(2, 3, 6, 3, 1, 7)
# פתרון:
dim_name <- c("E", "C", "A", "N", "O")
dim_ave_total <- c(mean(ave_E), mean(ave_C), mean(ave_A), mean(ave_N), mean(ave_O))
# הדפסת התשובה הסופית:
dim_name[max(dim_ave_total)]
```


`שאלה 2`   
פנו אליכם מהמחלקה למנהל עסקים וייעוץ עסקי. הם כרגע עורכים מחקר על מוסר עבודה ואבטלה. השערת המחקר שלהם נוגעת ליחס בין מוסר עבודה לנטיה לפתח הפרעות נפשיות (נוירוטיות). 
  במחווה של רצון טוב הסכמתם לעזור להם ולשלוח להם נתונים אנונימים של משתתפי המחקר. הם ביקשו לקבל וקטור הנקרא c_N_ratio של משתתפים מובטלים אשר מכיל את היחס בין נוירוטיות (N) למוסר עבודה (C).
  
רמז - שימו לב להגדרת פקטור בנתונים החדשים. אם יש צורך לערוך את הנתונים עשו זאת באמצעות קוד!

```{r final_ex_2, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_2-solution}
# נתונים:
employment <- c("yes", "yes", "No", "Yes", "No", "no")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_N <- c(5, 7, 2, 3, 7, 1)
# פתרון:
employment[employment=="yes"] = "Yes"
employment[employment=="no"] = "No"
employment <- as.factor(employment)

c_N_ratio <- (ave_N/ave_C)[employment=="No"]

# הדפסת התשובה הסופית:
c_N_ratio
```

## הגשת התרגיל
  סיימת? מעולה! עכשיו הגיע הזמן להגיש את התרגיל.  
  יש ללחוץ על הכפתור:  Generate  
  להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```

