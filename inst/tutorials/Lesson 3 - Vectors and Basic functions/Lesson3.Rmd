---
title: "Lesson 3: Vectors and Basic Functions"
author: "Chen"
date: "2024-09-09"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false
description: >
  <div style='direction: rtl;'>
  בשיעור זה נלמד סוג מסוים של משתנים, הוקטורים (משתנים המכילים יותר מערך אחד). נלמד גם על פונקציות בסיסיות של שפת התכנות שמאפשרות לבצע חישובים על וקטורים בקלות.
  </div>
runtime: shiny_prerendered
---

<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>


<!-- tutorial options and checking options - TODO set params -->
```{r setup, include=FALSE}
library(learnr)
library(gradethis)

tutorial_options(
  exercise.timelimit = 60,
    )

knitr::opts_chunk$set(error = TRUE)
gradethis::gradethis_setup()
```

## וקטורים
וקטורים הם משתנים הפשוטים ביותר שמכילים יותר מערך אחד. למשל אם נרצה לאמוד ערך אחד עבור כל תלמיד בכיתה ונרצה לאכסן את כל המידע של הכיתה במשתנה אחד.  
בR מגדירים וקטור על ידי שימוש ב`c()`. כל האיברים שיכנסו לוקטור יוגדרו בתוך הסוגריים ויופרדו בפסיק.  
לדוגמה:

```{r}
# דוגמה להגדרת וקטור
c(1, 2, 3, 4)

# גם וקטורים ניתן להגדיר כמשתנים
vector <- c(1, 2, 3, 4)
# אם נרצה להציגו
vector

# ניתן גם להגדיר כמה משתנים ואז לאסוף אותם בוקטור
a = 1
b = 2
c = 3
d = 4
vector_2 <- c(a, b, c, d)
vector_2

# האם התוצאה באמת זהה?
# בואו נשתמש בהשוואה 
vector == vector_2

```
שתי הערות חשובות:  
1. לאחר שהגדרנו את הוקטור השני, שמורכב מ4 משתנים שונים, הוא מכיל רק את הערכים ושינוי של המשתנים המקוריים לא יוביל אוטומטית לשינוי של הוקטור   
2. התוצר של ההשוואה ברמת הוקטור הוא בעצם וקטור נוסף אשר מכיל ערכים לוגיים בכל איבריו. אורך כל הוקטורים חייב להיות זהה כדי לבצע את ההשוואה הזאת בצורה נכונה.  



```{r vec_basic_question, echo = FALSE}
question(" מה לדעתכם הייתה התוצאה עבור ההשוואה הבאה:  
           vector_3 <- c(b, b, c, d)  
         vector == vector_3",
         answer("התוכנה הייתה מחזירה שגיאה",  message ="לא הייתה אמורה להתקבל שגיאה במקרה זה. רק במקרה שהינו מוסיפים עוד איבר לוקטור החדש, ההשוואה בין 5 ל4 ערכים לא הייתה מתאפשרת והיינו מקבלים שגיאה. "),
         answer("FALSE", message = "האמנם הוקטורים כבר לא זהים אבל שימו לב שהתוכנה תחזיר תשובה בנפרד לכל ערך בוקטור."),
         answer("[TRUE, FALSE, TRUE, TRUE]", message = "קרוב מאוד! אבל שימו לב לסדר, הערך הראשון הוא שהשתנה ולא השני. "),
         answer("[FALSE, TRUE, TRUE, TRUE]",correct =TRUE, message = "כיוון ששינינו את הערכך הראשון הוא כבר לא יהיה זהה ולכן האיבר הראשון בתוצאה ישתנה. שאר האיברים לא השתנו ולכן ישארו כמו בדוגמה"),
         allow_retry = TRUE
)
```

### שימו בנתונים
כעת נחזור לדוגמה שלנו מהשיעור הקודם על שאלון האישיות. כעת נוכל לקבל נתונים שונים עבור יותר ממשתתף אחד. כמו שלרוב נרצה לעשות במחקר.
קבוצת חברים מסוימת ענתה על השאלון שלנו, להלן סידור של נתוניהם בוקטורים:

```{r}
# וקטור השמות של המשתתפים - שימו לב! וקטור יכול להכיל גם מחרוזות ולא רק מספרים
c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# שימו לב, כדי שנשמור את הנתונים עלינו להגדיר משתנה
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# עכשיו נוכל לקבל גם מידע על ציונהם של הקבוצה בתכונה "מוסר עבודה" - C
ave_C <- c(6, 4, 2, 3, 7, 1)
```

`תרגיל`  
הגדירו וקטור נוסף של ציוני הקבוצה בתכונה של "מוחצנות". הגדירו וקטור חדש שנקרא ave_E ובו כל משתתף קיבל ציון של 3.

```{r def_vec_ex, exercise=TRUE, exercise.eval = FALSE}

  
```

```{r def_vec_ex-solution}

ave_E <- c(3, 3, 3, 3, 3, 3)

```

```{r def_vec_ex-check}
grade_this_code(correct = "מצויין!", incorrect = "לא הכנסתם את הקוד הנכון, בדקו את שם המשתנה ואת כמות הערכים שהייתם אמורים להכניס.")

```

### פעולות פשוטות על וקטורים
כמו שניתן לבצע פעולות השוואה עם וקטורים, ניתן גם להשתמש בכל אופרטור שיצא לנו להכיר. אבל חשוב לשים לב בין אילו וקטורים ניתן לבצע פעולות.  
מומלץ לבצע השוואות ופעולות בין שני וקטורים בעלי אורך זהה `או` בין ערך בודד לוקטור.  
מה יקרה אם נשווה בין וקטורים בעלי אורכים שונים? צריך לעשות זאת בזהירות כיוון שיש כמה אפשרויות. אם נשווה בין וקטור בעל 6 ערכים לוקטור בעל 5 ערכים נקבל שגיאה. אבל אם נשווה בין וקטור בעל 6 איברים ולקטור בעל כמות איברים שמתחלקת ב6 (למשל 12) או כמות איברים ש6 מתחלק בה (למשל 3 או 2) התוכנה תכפיל את הוקטור הקצר יותר ותבצע השוואה. 
למשל:  

```{r}
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

# אפשר לחבר וקטורים באותו האורך
ave_C + ave_E

# אפשר גם לכפול בינהם
ave_C * ave_E

# עוד...

# עכשיו ננסה להחסיר ערך בודד מכל הערכים בוקטור
ave_C-1 

# או להעלות את הוקטור בחזקת 3
ave_C ^3

# ננסה להשוות לוקטור חדש עם 3 איברים
v = c(1, 2, 3)
ave_E == v

# ועכשיו לוקטור עם 5 איברים
v = c(1,2,3,4,5)
ave_E == v

```


נתונה לכם שורת הקוד הבאה:
ave_E-c(1, 2)
```{r vec_op_question, echo = FALSE}
question("מה יקרה אם ננסה להריץ את שורת הקוד למעלה?",
         answer("התוכנה הייתה מחזירה שגיאה",  message =" כאשר משווים שני וקטורים בעלי אורכים שונים יש סכנה שנקבל שגיאה, אבל במקרה הזה האורך של הוקטור המקורי מתחלק ב2"),
         answer("FALSE", message = "שורת הקוד מבצעת חיסור ולא השוואה, גם אם הייתה מתבצעת השוואה היינו מקבלים ערך אחד עבור כל איבר בוקטור הארוך יותר"),
         answer("[FALSE, FALSE, FALSE, FALSE, FALSE, FALSE]", message = "קרוב מאוד! אבל שימו לב ששורת הקוד לא מבצעת השוואה אלא חיסור."),
         answer("2 1 2 1 2 1",correct =TRUE, message = "נכון, התוכנה תשכפל את הוקטור הקצר 3 פעמים ותבצע חיסור כאילו מדובר בוקטורים עם אותו אורך"),
         allow_retry = TRUE
)
```

## אינדקסים
כאשר אנחנו נבצע את המעבר ממשתנה בעל ערך יחיד למשתנה רב ערכים (הוקטור) אנחנו נצטרך להשתמש באינדקסים כדי לגשת לערכים בודדים שנמצאים בתוך הוקטור.
בשפת התכנות R כל ערך מקבל מספר, כאשר הערך הראשון בתוך הוקטור הוא באינדקס 1 (שימו לב, אולי זה נראה לכם מאוד אינטואטיבי שמתחילים לספור ב1, אבל אם אתם מכירים שפות תכנות אחרות אולי אתם רגילים ש-0 הוא האינדקס הראשון אז חשוב לקחת בחשבון את השינוי). האינדקס האחרון הוא תמיד מספר האיברים שקיימים בוקטור. 

האינדקסים הם בעצם גורם שיכול לעזור לנו לאחד בין שני וקטורים שונים. כמו בדוגמה הראשונה שלנו, ראינו שיש וקטור אחד עם שמות המשתתפים ווקטור אחר עם דירוגיהם בשאלון. 
כעת נלמד איך לגשת לערכים שונים באמצעות אינדקס.

כעת ננסה לשלוף את הערכים של המשתתף השלישי במחקר:
```{r}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

names[3]
ave_C[3]
ave_E[3]
```
דוגמה נחמדה, קיבלנו את הערכים של ג'ואי 
עכשיו נלמד גם איך לשלוף כמה ערכים לפי אינדקס.

```{r}
# אם מעוניינים בטווח של ערכים רציפים ניתן גם להשתמש באפשרות זאת:
ave_C[1:3]
# אם אנחנו רוצים דווקא ערכים לא רציפים אפשר להגדיר וקטור נפרד עם הערכים שרצוניים לנו:
ind <- c(1,3,6)
ave_C[ind]
```
  
אבל מה נעשה אם יבקשו מאיתנו לוודא מה התוצאות של רוס? כרגע קל לנו לראות שהוא ראשון ברשימה, אבל אם היו 1000 משתתפים כבר היינו צריכים לפנות לאסטרטגיה אחרת.   
נוכל פשוט לפנות להשוואה בין וקטורים  

```{r}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

names=="Ross"

# עכשיו יש לנו וקטור שמסמן לנו איפה בוקטור השמות מתקיים התנאי. אפשר להשתמש בוקטור הזה כאינדקס כך:
ave_C[names=="Ross"]
ave_E[names=="Ross"]
```
שימו לב, הערכים ששבהם התנאי מתקיים וקיבלו את הערך TRUE בוקטור של תוצאת ההשוואה הודפסו.

  
`תרגיל`  
בנוסף לנתונים הקודמים נתון לכם וקטור חדש אשר מציין את המגדר של כל משתתף במחקר.
קודם כל הציגו את תוצאותיהן של כל הנשים בתכונה C.  
לאחר מכן הדפיסו את כל השמות של המשתתפים שערך C שלהם הוא גבוה מ3.

```{r index_ex, exercise=TRUE, exercise.eval = FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)

# הציגו את תוצאות הנשים כאן:

# הציגו את השמות שקיבלו ערך מעל 3 כאן:

```

```{r index_ex-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)
# הציגו את תוצאות הנשים כאן:
ave_C[gender=="F"]
# הציגו את השמות שקיבלו ערך מעל 3 כאן:
names[ave_C>3]

```

```{r index_ex-check}
grade_this_code(
  correct = "הקוד שכבתבת מדויק! חשוב לשים לב לתשובת שקיבלת כאן, התוצאה היא בעצם וקטור נוסף וכמות האיברים בו היא כמות האיברים עבורם תוצאת ההשוואה יצאה חיובית", incorrect = "הקוד שלך לא מציג את הפריטים שהתבקשתם להציג. יש לבדוק את התנאים שהכנסת"
)
```


### עריכת וקטורים
גם לכם הוקטור של התכונה E נראה מוזר? מי שמכיר את החברים בוודאי יודע שלא לכולם יש רמת מוחצנות זהה.   
בואו נשנה את רמת המוחצנות של ג'ואי ל6.
```{r}
ave_E <- c(3, 3, 3, 3, 3, 3)
# לפי הסדר המקורי נרצה לשנות את הערך השלישי
ave_E[3] <- 6
# בואו נראה מה יצא
ave_E

```
בעצם יש לנו דרך טובה יותר לשנות ערכים!

`תרגיל`  
עכשיו שנו אתם את שאר הערכים שאינם נכונים. שנו את הערך של פיבי ל5 ואת הערך של רוס וצ'נדלר ל1. 

```{r ed_vec_ex, exercise=TRUE, exercise.eval = FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:

```

```{r ed_vec_ex-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:
ave_E[names=="Phoebe"]<-5
ave_E[names=="Ross"|names=="Chandler"]<-1



```

```{r ed_vec_ex-check}
grade_this_code(correct = "מעולה! ביצעת את כל העריכות הנדרשות", incorrect = "הקוד איננו נכון, בשאלה התבקשתם למצוא את האינדקס לעריכת הוקטור על ידי שם המשתתף. האם השתמשת בשם? אם כן יש לבדוק שהשתמשת בהשוואות הנכונות לביצוע העריכה.")
```


## פונקציות בסיסיות
אז עכשיו שהגענו שכבר אספנו לא מעט נתונים על החברים אפשר להתחיל להסתכל על התוצאות שלהם ברמת הקבוצה. 
בשיעור הקודם למדנו איך לבצע חיבור וחיסור למשל. ונוכל להתחיל לחשב את סכום ציוניהם של החברים בתכונה E כך:
```{r}
# נחזור לוקטור שיצרנו בתרגיל הקודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# נחשב את הסכום הכולל באמצעות פעולת חיבור
ave_E_sum <- ave_E[1] + ave_E[2] + ave_E[3] + ave_E[4] + ave_E[5] + ave_E[6]

ave_E_sum
```

קצת מתיש לא?
כעת נלמד איך לבצע מספר פעולות פשוטות על וקטורים
הדרך שהכרנו עד עכשיו תדרוש מאיתנו לבודד איבר איבר ולחבר בניהם באמצעות +. אך שפת התכנות יצרה עבורינו _פונקציות_ אשר יכולות לבצע פעולות שכאלה בצורה יעילה
למשל הפונקציה `sum()`

```{r}
# נחזור לוקטור שיצרנו קודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# ועכשיו באמצעות הפונקציה sum()
ave_E_sum <- sum(ave_E)
ave_E_sum
```

התוצאה שהתקבלה כמובן זהה, אבל כמות העבודה שונה מהותית. 

כמה עקרונות חשובים לעבודה עם פונקציות:  
1. שם הפונקציה בדומה למשתנים נכתב ללא גרשיים  
2. שם הפונקציה צריך להיכתב במדוייק, למשל הפונקציה Sum איננה קיימת ובמידה ותנסו להשתמש בה תתקבל שגיאה.  
3. השימוש הנכון בפונקציה הוא - שם הפונקציה ואחריה סוגריים. בתוך הסוגריים נכניס את הקלט של הפונקציה (כל פונקציה והקלט שמתאים לה).  
4. הפונקציה מחזירה לנו פלט (התוצאה, למשל במקרה של sum את הסכום). את הפלט אפשר לשמור במשתנה כמו בדוגמה למעלה. אם לא נשמור אותו למשתנה הפלט פשוט יודפס.  


### ארגומנטים
כעת נרחיב מעט על הקלט של פונקציות. 
בתוך הסוגריים של הפונקציה אנחנו נצטרך לפרט את ה`ארגומנטים` (Arguments) שנרצה להכניס לפונקציה. למשל במקרה של הפונקציה sum הארגומנט היחיד שהכנסנו היה הוקטור שרצינו לסכום. אם נרצה לסכום כמה מספרים או כמה וקטורים נוכל להכניס יותר מארגומנט אחד. הארגומנטים צריכים להיות מופרדים `בפסיק`. ארגומנטים לא חייבים להיות רק וקטורים או מספרים, לחלק מהפונקציות יש גם הגדרות ופרמטרים שונים שאפשר לפרט להן.   

בפונקציה sum() (וגם בפונקציות רבות אחרות) מלבד הוקטור אנחנו יכולים להכניס עוד ארגומנט אחד לפונקציה `na.rm`.


### ערכים חסרים
במהלך איסוף נתונים ניתקל לא פעם במקרים בהם יהיו לנו נתונים חסרים. למשל אם פיבי איבדה סבלנות באמצע הניסוי ולא קיבלנו עבורה ערך של מוחנצות. לרוב מה שיקרה זה שהתא שאמור היה להכיל את הערך הזה יקבל ערך חסר, בשפת התכנות יש ערך מיוחד למקרים כאלה והוא נקרא `NaN` או `NA`. זהו ערך שיכול להחליף כל ערך אחר והוא שייך לקטגוריה חדשה של `ערכים חסרים` כלומר הוא לא מספר ולא טקסט.  

עכשיו נחזור לפונקציה ולארגומנט שמאפשר לנו לקבוע האם הפונקציה (סכום או כל פונקציה אחרת) תתעלם מערכים חסרים או לא. אם נכניס לארגומנט na.rm את הערך TRUE היא תתעלם מהם ואם FALSE (או שלא נפרט כלום) היא תתחשב בהם.  
מה שבעצם יקרה זה שלא ניתן לחשב סכום הכולל ערכים חסרים (שכן אין להם ערך מספרי) ולכן לא נקבל תוצאה כלל.

למשל:

```{r}
# נחליף את אחד הערכים בערך חסר
ave_E <- c(1, 1, 6, 3, 3, NaN)

# ועכשיו באמצעות הפונקציה sum()
ave_E_sum <- sum(ave_E)
ave_E_sum
# קיבלנו ערך חסר, שכן לא ניתן לחשב איתו ממוצע.
# ועכשיו נוסיף את הארגומט הנוסף
ave_E_sum <- sum(ave_E, na.rm=TRUE)
ave_E_sum
```
עכשיו חושב לנו ממוצע ללא ערכים חסרים, התוכנה פשוט מתעלמת מהערך החסר ומחשבת את הסכום של 5 האיברים האחרים.  

עכשיו נכיר עוד כמה פונקציות נוספות:  
פונקציה נוספת שיכולה להיות שימושית היא הפונקציה `length()`. כמו שיכולתם לנחש, פונקציה זאת מחשבת את האורך של הוקטור, או יותר נכון את כמות האיברים שלו.
אם נריץ את שורת הקוד הבאה:  
length(ave_E_sum)  

```{r vector_question, echo = FALSE}
question(" מה תהיה התוצאה?",
         answer("1", correct = TRUE, message ="נכוןת במשתנה בו חישבנו את הסכום יש ערך אחד בלבד"),
         answer("19", message = "זאת תהיה התוצאה של הפונקציה שמחשבת את סכום הוקטור ולא האורך שלו"),
         answer("FALSE", message = "זהו ערך לוגי, אורך הוקטור יהיה מספר"),
         answer("6", message = "קרוב אבל לא בדיוק! בוקטור המקורי של הנתונים שלנו יש 6 איברים."),
         allow_retry = TRUE
)
```

`תרגיל`
עכשיו חשבו את ממוצע של החברים בתכונה E באמצעות הפונקציה sum והפונקציה length.  
תזכורת - ממוצע מחושב על ידי סכימה של כל האיברים חלקי מספר האיברים.
  
```{r mean_ex, exercise=TRUE, exercise.eval = FALSE}
ave_E <- c(1, 1, 6, 3, 3, 5)
# חשבו את הממוצע כאן:
total_ave_E <-
```

```{r mean_ex-solution}
ave_E <- c(1, 1, 6, 3, 3, 5)
# ערכו את הוקטור כאן:
total_ave_E <- sum(ave_E)/length(ave_E)

```

```{r mean_ex-check}
grade_this_code(correct = "כל הכבוד! חישבת את הממוצע נכון באמצעות הפונקציות!", incorrect = "הקוד שלך עוד לא מדוייק. האם השתמשת בפונקציות המתוארות? אפשר להגיע לתוצאה גם על ידי שימוש בפעולות אריתמתיות אך הפעם התבקשתם להשתמש בפונקציות. חשוב לשים לב לסוגריים של הפונקציות ולשימוש בתי הפונקציות נכונה כדי להגיע לממוצע.")

```

###
האמנם זה היה הרבה יותר קל מאשר החישוב באמצות אופרטורים, אבל יש דרך אפילו יותר קצרה. הפונקציה:
`mean()` 

```{r}
# ננסה לחזור על התרגיל
ave_E <- c(1, 1, 6, 3, 3, 5)
# נבצע את החישוב כך:
total_ave_E <- mean(ave_E)
total_ave_E
```


### פונקציות שכדאי להכיר
`var` - פונקציה המחשבת את השונות (מדד לסטיה מהממוצע בריבוע)  
`sd` - מחשב את סטיית התקן (מדד לסטיה הממוצעת מהממוצע)  
`min` - מחזיר לנו את הערך המינימלי בוקטור  
`max` - מחזיר לנו את הערך המקסימלי בוקטור  
`unique` - מחזיר לנו וקטור חדש ובו רק הערכים הייחודיים שמופיעים בוקטור  
`sort` - פונקציה המחזירה לנו וקטור חדש, עם כל הערכים שקיימים בוקטור המקורי
רק בסדר עולה (אם מדובר במספרים) או לפי הא-ב אם מדובר במחרוזות.  
`round` - פונקציה המקבלת שבר בודד או וקטור המכיל שברים ומעגלת אותו. ניתן להכניס לפונקציה את כמות הספרות שנרצה לשמור לאחר הנקודה העשרונית. למשל: 

```{r}
num = 99.51335323
round(num)
```

דוגמה זאת מדגישה לנו את החשיבות של הארגומנטים. גם אם לא נפרט את כולם לתוכנה יש תמיד ברירת מחדל (default) לכל הפרמטרים של הפונקציות. 

```{r}
# ננסה כן לפרט
round(num, 1)

round(num, 2)

```
כלומר העיגול ממש יכול לשנות לנו את התוצאה שמתקבלת

### סוגי משתנים למתקדמים
עכשיו, נכיר עוד סוג אחד של משתנה שלא הכרנו בשיעור הקודם `הפקטור - factor`.
הפקטור הוא וקטור שמזכיר קצת וקטור לוגית מהבחינה שהוא יכול לקבל רק ערכים מסויימים, אך הוא לא מוגבל לנכון ולא נכון אלא יכול לקבל כל סוג ערכים שנרצה.
למשל הוקטור שהכיל את המגדר של החברים, הוא וקטור עם ערכים שאנחנו הגדרנו אבל הוא יכול לקבל רק סט מסוים של ערכים (גבר או אישה).  
כעת נראה דוגמה להגדרה של פקטור:

```{r}
# כדי לסווג משתנה כפקטור נשתמש בפוקנקציה 
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# הפונקציה הבאה תוכל להראות לנו איזה ערכים וקטור כזה יכול לקבל:
levels(gender)

```

שימו לב! כעת הוקטור מוגבל ולא ניתן להוסיף לו ערכים שלא היו קיימים בוקטור המקורי.   
למשל, פיבי ביקשה שלא יציינו עבורה את משתנה זה. בכל מחקר צריך לאפשר למשתתפים להרגיש בנוח. לכן נרצה להוסיף רמה שלישית: Unknown  או בקיצור U

```{r}
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# ננסה להכניס את הערך U
gender[6] <- "U"

# התוכנה מעלה לנו שגיאה. 
# לא ניתן לבצע את הפעולה הזאת! קודם כל הרמות של המשתנה צריכות לכלול את האופציה הזאת. נערוך אותן כך:
levels(gender) <- c("M", "F", "U")

# ננסה שוב
gender[6] <- "U"

# ועכשיו נציג
gender

# אם נחליט שהשימוש באותיות לא נוח אפשר פשוט לשנות את השמות של הרמות השונות כך:
levels(gender) <- c("Female", "Male", "Unknown")

# דרך מאוד יעילה לערוך שינוים!
gender
```


בהקשר זה יש עוד שני סוג וקטורים שלפעמים נרצה לעבור בינהם. לכן כדאי להכיר את הפונקציות:

`as.numeric()` - תהפוך את הפורמט של הוקטור כולו למספרי. התוצאה תהיה int או float בהתרם למה שקיים בוקטור. פונקציה זאת שימושית במיוחד במקרים שיש ספרות בפורמט של טקסט ורוצים לבצע עליו פעולות מספריות.   

`as.character()` - תהפוך את הפורמט כולו לטקסט (character הן בעצם אותיות או תוים, אבני הבנין של המחרוזות). פונקציה זאת שימושית אם רוצים להשתמש במספרים בפורמט טקסט או לאחד בוקטור אחד טקסט ומספרים. כיוון שלאותיות אין משמעות מספרית, כאשר יהיה לנו וקטור שכולל גם מחרוזות הפורמט של הוקטור לא יכול להיות מספרי.

ואחרונה חביבה:
`class()` - פונקציה שתדפיס לנו לאיזה סוג משתייך הוקטור. הכניסו את שם המשתנה בסוגריים והפונקציה תדפיס לכם את התשובה.


## תרגיל מסכם

 
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")  
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))  
employment <- c("yes", "yes", "No", "Yes", "No", "no")  
income <- c(75, 100, 20, 50, 80, NaN)  

תשובות לשאלונים בכל המימדים:  
ave_E <- c(1, 1, 6, 3, 3, 5)  
ave_C <- c(6, 4, 2, 3, 7, 1)  
ave_A <- c(4, 4, 5, 7, 3, 6)  
ave_N <- c(6, 7, 1, 3, 6, 2)  
ave_O <- c(2, 3, 6, 3, 1, 7)  

שימו לב, זה זמן טוב להתחיל לתרגל את הרעיון של סביבת עבודה. בתרגילים הבאים כבר נתחיל לפנות אתכם החוצה מן הלומדה אל התוכנה עצמה. אבל לפני שנעשה זאת נכיר לעומק את המושג של "סביבת עבודה". כלומר, כל פעם שאנחנו מריצים שורת קוד שכוללת הגדרה של משתנים המשתנים קיימים לנו בסביבה ואנחנו יכולים להשתמש בהם מבלי להגדיר אותם מחדש. בתרגילים מטה, כל תיבת פתרון של שאלה מהווה סביבת עבודה נפרדת. לכן עליכם להבין איזה משתנים תצטרכו לפתרון השאלה והעתיקו אותם.
  
`שאלה 1`  
לאחר ההששתתפות במחקר החברים ביקשו לקבל חוות דעת על האישיות שלהם. הם היו רוצים לדעת מה היא תכונת האישיות הכי דומיננטית בקבוצה שלהם.  
כלומר, עליכם לחשב את הממוצע של החברים בכל תכונת אישיות בנפרד ולהדפיס את התכונה בעלת הערך הגבוה ביותר.

```{r final_ex_1, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_1-solution}
# נתונים:
ave_E <- c(1, 1, 6, 3, 3, 5)
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_A <- c(4, 4, 5, 7, 3, 6)
ave_N <- c(6, 7, 1, 3, 6, 2)
ave_O <- c(2, 3, 6, 3, 1, 7)
# פתרון:
dim_name <- c("E", "C", "A", "N", "O")
dim_ave_total <- c(mean(ave_E), mean(ave_C), mean(ave_A), mean(ave_N), mean(ave_O))
# הדפסת התשובה הסופית:
dim_name[max(dim_ave_total)]
```

```{r final_ex_1-check}
grade_this({if (identical(.result, "N")) {
    pass("מצויין! התכונה בעלת הציון הגבוה ביותר היא N. בונוס - הידעת שאם תשתמשו בפונקציה max על מחרוזות היא תחזיר את הערך הגבוה ביותר לפי האלף-בית? ")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})

```

`שאלה 2`   
פנו אליכם מהמחלקה למנהל עסקים וייעוץ עסקי. הם כרגע עורכים מחקר על מוסר עבודה ואבטלה. השערת המחקר שלהם נוגעת ליחס בין מוסר עבודה לנטיה לפתח הפרעות נפשיות (נוירוטיות). 
  במחווה של רצון טוב הסכמתם לעזור להם ולשלוח להם נתונים אנונימים של משתתפי המחקר. הם ביקשו לקבל וקטור הנקרא c_N_ratio של משתתפים מובטלים אשר מכיל את היחס בין נוירוטיות (N) למוסר עבודה (C). עגלו את התוצאות לשתי ספרות אחרי הנקודה העשרונית.  
  
רמז - שימו לב להגדרת פקטור בנתונים החדשים. אם יש צורך לערוך את הנתונים עשו זאת באמצעות קוד!

```{r final_ex_2, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# ערכו את הנתונים כאן:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_2-solution}
# נתונים:
employment <- c("yes", "yes", "No", "Yes", "No", "no")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_N <- c(6, 7, 1, 3, 6, 2)
# ערכו את הנתונים כאן
employment[employment=="yes"] = "Yes"
employment[employment=="no"] = "No"
employment <- as.factor(employment)
# פתרון:
c_N_ratio <- round((ave_N/ave_C)[employment=="No"],2)

# הדפסת התשובה הסופית:
c_N_ratio
```

```{r final_ex_2-check}
grade_this({if (identical(.result, c(0.50, 0.86, 2.00))) {
    pass("מעולה! המחלקה למנהל עסקים מודה לכם!")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})
```

`שאלה 3`  
הפעם פנו אליכם מהמחלקה לכלכלה, הם עורכים מחקר על הקשר בין מוסר עבודה והפליה מגדרית בשכר.  
כדי לעמוד את ההפליה המגדרית בשכר הם מבקשים לקבל את וקטור המכיל את ההפרש הממוצע של שכר הנשים משכר הגברים בעלי מוסר עבודה גבוה (מעל 3 - האיבר הראשון) ונמוכה (מתחת או שווה ל3 - האיבר השני).


```{r final_ex_3, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_3-solution}
# נתונים:
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))  
income <- c(75, 100, 20, 50, 80, NA)  
ave_C <- c(6, 4, 2, 3, 7, 1)

# פתרון:
high_c <- mean(income[gender=="F" & ave_C >3], na.rm=TRUE) - mean(income[gender=="M" & ave_C >3], na.rm=TRUE)

low_c <- mean(income[gender=="F" & ave_C <=3], na.rm=TRUE) - mean(income[gender=="M" & ave_C <=3], na.rm=TRUE)


# הדפסת התשובה הסופית:
gender_gap =c(high_c, low_c)
```

```{r final_ex_3-check}
grade_this({if (identical(.result, c(-7.5, 30))) {
    pass("יפה מאוד! קיבלנו שאצל נשים בעלות מוסר עבודה גבוהה יש אפילו פער שלילי בשכר (כלומר הן מרוויות יותר מגברים). החוקרים מהמחלקה לכלכלה בטוח יתעניינו בנתונים האלר!")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})

```

## הגשת התרגיל
  סיימת? מעולה! עכשיו הגיע הזמן להגיש את התרגיל.  
  יש ללחוץ על הכפתור:  Generate  
  להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```

