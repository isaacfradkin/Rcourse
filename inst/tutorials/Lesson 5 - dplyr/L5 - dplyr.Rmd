---
title: "Lesson 5: dplyr" 
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false
    
    
description: >
  <div style='direction: rtl;'>
  השיעור נוגע בפונקציות המאוגדות תחת החבילה dplyr נלמד לסנן, לערוך ולסדר טבלאות, ולצרף יחד נתונים ממספר מקורות שונים.
  </div>
       
runtime: shiny_prerendered  
editor_options: 
  markdown: 
    wrap: 72
---


```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>
```
<!-- tutorial options and cheching options - TODO set params -->

```{r setup, include=FALSE}
library(learnr)
library(dplyr)
library(gradethis)
library(Rcourse)

tutorial_options(
  exercise.timelimit = 60,
)


knitr::opts_chunk$set(error = TRUE)
```

```{r prepare-df1}




```

```{r prepare-rbind}

# row bind

df_partial1 = 1
df_partial2 = 1

# column bind

df_first_columns = 1
df_last_columns = 1
  
```

```{r prepare-table2}
table2 = need_for_cognition %>%
  mutate(nfc_02 = 6 - nfc_02r,  # נהפוך את הקידוד של שלושת העמודות ההפוכות
         nfc_03 = 6 - nfc_03r,
         nfc_06 = 6 - nfc_06r,
         # נחשב את ממוצע ששת השאלות.
         # שימו לב - אפשר להשתמש בעמודות שיצרנו מוקדם יותר בתוך הפונקציה
         nfc    = (nfc_01 + nfc_02 + nfc_03 + nfc_04 + nfc_05 + nfc_06)/6,
         
         age_above_18 = age >=18,  # האם הנבדק מעל גיל 18
         
         gender = recode(gender, "male" = "M", "female" = "F"), # דריסת עמודת המגדר וקידוד מחדש של הערכים שנמצאים בה
                     # פונקציה זו מאפשר לנו לקודד מחדש עמודות עם מספר רמות - להחליף את הערכים המייצגים קבוצות שונות 
         
         # תקנון ציוני המדד ויצירת ציוני תקן - באופן שמתעלם מערכים חסרים
         nfc_Z_score = (nfc - mean(nfc,na.rm = T)) / sd(nfc, na.rm = T)  
         
         )
```

##  מבוא

בשיעור זה נלמד להשתמש במגוון פונקציות המאוגדות תחת החבילה dplyr.

פונקציות אלו מאוד נפוצות בשימוש בR כיוון שהן מאפשרות לעבד קבצי נתונים
באופן פשוט ומסודר. בחלק מהמקרים הפונקציות שנפגוש יאפשרו לנו לעשות דברים
שכבר למדנו איך לעשות בשיעורים הקודמים (משל - חיתוך של שורות או עמודות
מתוך טבלה) אך הן יעשו זאת באופן שיאפשר לנו לשמור את הקוד שלנו קריא
ותמציתי. במקרים אחרים נפגוש פונקציות שמאפשרות לנו לעשות עיבודים חדשים
שעוד לא פגשנו.

השיעור ארוך יותר מהשיעורים הקודמים, אך הוא נוגע בתחום מרכזי מאוד בשימוש
בתוכנה ולכן מומלץ להקדיש לו זמן וקשב, שכן אלו פונקציות שנמצאות בשימוש
תדיר בעיבוד נתונים.



### פקד ההעברה

לפני שנגיע לשימוש בפונקציות עצמן, נרצה להתעכב על פקד חדש הנכלל בחבילה
זו - פקד ההעברה (או באנגלית - piping). פקד זה מיוצג על ידי הסימון `%>%`
ואפשר לחשוב עליו כעל צינור שמעביר את האובייקט שלפניו לפונקציה שמופיעה אחריו.

למשל, במקום לכתוב `mean(vector1)` נוכל לכתוב `vector1 %>% mean()`. הפקד יקח את הוקטור `vector1` ויעביר אותו אל תוך הפונצקציה `mean`.

לפניכם מספר דוגמאות נוספות. כל צמד שורות מבצע את אותה הפעולה בדיוק.

```{r}
# וקטור הציונים
scores = c(80.2,75.5,60,75.5,75.5,75.5,84,80.2,94)

# סינון כפילויות
unique_scores = unique(scores)
unique_scores = scores %>% unique()
print(unique_scores)

# עיגול הציונים
rounded_scores = round(scores, digits = 0)
rounded_scores = scores %>% round(digits = 0)
print(rounded_scores)
```

#### למה זה טוב?

כל עוד אנחנו משתמשים בפונקציה אחת, אין לשימוש בפקד זה יתרון משמעותי.
היתרון העיקרי מגיע כשאנחנו רוצים להשתמש בכמה פונקציות ברצף. במקרים כאלו,
אנחנו יכולים להכניס את התוצר של כל פונקציה בתוך הפונקיה הבאה, אבל כתיב
כזה ייצר קוד מאוד מסורבל. הפקד מאפשר לנו לכתוב את אותו הקוד באופן הרבה
יותר מסודר ונח לקריאה. נוכל גם לרווח את הקוד לשורות שונות ולהוסיף הערות
שיעזרו לנו לזכור מה עושה כל שלב בניתוח.

למשל - נוכל להשתמש בפקד ההעברה כדי לחשב את **מספר** הערכים הייחודיים בוקטור הציונים שלנו:

```{r}
# וקטור הציונים
scores = c(80.2,75.5,60,75.5,75.5,75.5,84,80.2,94)

## ללא פקד העברה
n_unique_scores = length(unique(scores))

## עם פקד העברה
n_unique_scores = scores %>%
  unique() %>%  # מסננים כפילויות
  length()      # ואז מחשבים את אורך הוקטור 
```

הקוד שנכתב באמצעות הפקד מסודר יותר ונח יותר לקריאה.


שימו לב - כשאנחנו משתמשים בפקדי העברה, תוצרי הביניים של הפונקציות לא
נשמרים. התוצר היחיד שישמר הוא התוצר של הפונקצייה האחרונה בשרשרת, והוא
יישמר תחת שם האובייקט שאליו ביצענו את ההשמה.


כדוגמה נוספת, נדפיס את ממוצע שורשי הציונים.

```{r}
# וקטור הציונים
scores = c(80.2,75.5,60,75.5,75.5,75.5,84,80.2,94)

# ללא פקד ההעברה
print(round(mean(sqrt(scores)),digits = 1))

# עם פקד ההעברה
scores %>%
  sqrt()%>%                # חישוב שורשי הציונים
  mean()%>%                # חישוב הערך הממוצע מתוך שורשי הציונים
  round(digits = 1) %>%    # עיגול הממוצע שחושב לספרה אחת אחרי הנקודה העשרונית
  print()                  # הדפסה

```


בדוגמה הזו היתרון של כתיבה באמצעות פקדי העברה נהיה קצת יותר ברור. במהלך השיעור נראה דוגמאות נוספות ליתרון של שימוש בפקד זה.
  


`תרגיל` כתבו מחדש את הקוד הבא באמצעות פקד העברה:


```{r} 
numbers_as_text = c("12","14","15","7","34","22","17")
mean_number = round(mean(as.numeric(numbers_as_text)),2)
print(mean_number)
```


```{r piping_exercise,  exercise=TRUE, exercise.eval = FALSE}

numbers_as_text = c("12","14","15","7","34","22","17")
mean_number = _________________________________
print(mean_number)

```

```{r piping_exercise-solution}

numbers_as_text = c("12","14","15","7","34","22","17")
mean_number = numbers_as_text %>%
  as.numeric() %>%
  mean() %>%
  round(2)
print(mean_number)

```

```{r piping_exercise-check}
grade_this_code()
```


## בחירת עמודות

הפונקציות הראשונות בהן נשתמש מבצעות פעולות שכבר התנסנו בהם. למשל - הפונקציה `select` מאפשרת לנו לייצר טבלה חדשה מתוך העמודות של טבלה קיימת. אנחנו יכולים לציין את שמות העמודות
שאנחנו רוצים **להשאיר**, או את אלו שאנחנו רוצים
לסלק (בליוויסימן מינוס).

כך או כך, הפונקציה מייצרת טבלה **חדשה** מתוך החיתוך שעשינו. היא **לא** עורכת
את הטבלה המקורית שהכנסנו לפונקציה.

במידה ואנחנו רוצים לערוך את אותה הטבלה אנחנו יכולים לשמור את הטבלה
המעודכנת תחת שמה של הטבלה המקורית ובכך לדרוס את הגרסה הישנה ולהחליף אותה
במעודכנת.

הנה כמה דוגמאות:

```{r}

# נשתמש בטבלה שייבאנו בשיעור הקודם, המכילה את נתוני שאלון 
# need for cognition

# בחירת העמודות המציינות את מספר ההרצה, את מין הנבדק ואת הגיל שלו
demographic_data = need_for_cognition %>% 
  select(session_id,age,gender)

head(demographic_data)

# השמטת העמודה הראשונה ועמודות בדיקת העירנות
no_attention_check = need_for_cognition %>%
  select(-1,-attention_check)

head(no_attention_check)

# עדכון הטבלה שיצרנו כך שלא תכיל את נתוני הגיל
need_for_cognition = need_for_cognition %>% 
  select(-age) 
```


```{r Q1, echo = FALSE}
question("אם היינו מריצים את קטע הקוד האחרון (עדכון הטבלה שיצרנו כך שלא תכיל את נתוני הגיל) פעמיים ברציפות - היינו מקבלים הודעת שגיאה. מדוע?",
         
         answer("כיוון שאי אפשר להריץ את אותו הקוד פעמיים"),
         answer("כיוון שהטבלה בה אנו משתמשים כבר לא קיימת"),
         answer("כיוון שהטבלה גדולה מדי"),
         answer("כיוון שאנחנו מנסים להסיר מהטבלה עמודה שכבר לא קיימת בה", correct = TRUE),
         allow_retry = TRUE
)
```



### בחירת עמודות המכילות תווים מסוימים

יישום שימושי נוסף של פונקציה זו הוא שהיא מאפשרת לבחור עמודות על סמך
התוכן של שמות העמודות. למשל - באמצעות הפונקציה `contains` נוכל לבחור את
כל העמודות המכילות רצף תווים מסוים. אפשרות זו שימושית כשאנחנו רוצים
לבחור קבוצה של עמודות ששמרנו בשם דומה - למשל תשובות לשאלות שונות באותו
השאלון.

בדוגמה למטה אנחנו חותכים מתוך הטבלה הכללית שלנו תת-טבלה המכילה רק את
התשובות לשאלון ואת המספר המזהה של התגובה של כל נבדק

```{r}

questions_and_sesion_id = need_for_cognition %>%
  select(session_id,contains("nfc"))

head(questions_and_sesion_id)
                
```


### שליפת עמודה כוקטור

שימו לב - כשנבצע בחירת עמודות באמצעות select)( נקבל חזרה טבלה - גם אם
בחרנו רק עמודה אחת. במידה ונרצה לבצע חיתוך של עמודה בודדת **כוקטור** ולא
כטבלה נוכל להיעזר בפקד ה\$, או להשתמש בפקודה pull() המבצעת פעולה דומה.
בדוגמה הבאה אנו נעזרים בפקודה זו על מנת לבחון מה הם הערכים השונים
המוכלים בעמודה gender.


```{r}

need_for_cognition %>% pull(gender) %>% # שליפת העמודה המכילה את נתוני המגדר
  unique() %>%              # פונקציה המשיבה וקטור שמונה את הערכים השונים הקיימים בוקטור
  print()                   # הדפסה

```

ניתן לראות שהעמודה מכילה ערכים המעידים על נבדקים זכרים, נקבות וערכים חסרים כלשהם


## סינון שורות

עכשיו שבררנו את העמודות הנחוצות לנו - נוכל לעבור לעיסוק המשלים: סינון שורות.

גם כאן נוכל לשמור או להשמיט שורות לפי המספר הסידורי שלהן, באמצעות הפקודה
`slice` , אך ברוב המקרים סינון השורות שנרצה לבצע יהיה תלוי בתוכן של
השורות עצמן ולא במספר הסידורי שלהן.

למשל - ייתכן ונרצה לסנן מתוך קובץ הנתונים שלנו את כל הנבדקים שלא סיימו
את הניסוי, הנבדקים שנמצאים מחוץ לטווח גילאים מסויים או שחסרים להם נתונים
חשובים.

בשביל פעולות כאלו, שהינן תנאי הכרחי כמעט בכל ניתוח שנערוך, ניעזר
בפונקציה `filter`.

פונקצייה זו מקבלת את הטבלה עליה נרצה לבצע את הסינון (באופן ישיר או
באמצעות פקד ההעברה), ותנאי לוגי שיקבע אילו שורות **ישארו**. תנאי זה יתבסס על
עמודה אחת או יותר מתוך הטבלה.

נמחיש באמצעות מספר דוגמאות:

```{r}

# שמירת כל הנבדקים שעמדו בבדיקת תשומת הלב בניסוי

filtered_table1 = need_for_cognition %>%
  filter(attention_check == 1) 

# שמירת כל הנבדקים בין גילאי 20 ו30 (כולל)

filtered_table2 = need_for_cognition %>%
  filter(age >20 & age <=30) 

 # שמירת הנבדקים הגברים בלבד (סינון נשים וערכים חסרים)

filtered_table3 = need_for_cognition %>% 
  filter(gender == "male") 

# שליפת הנתונים של 3 נבדקים ספציפיים, על פי מספר מזהה

filtered_table4 = need_for_cognition %>% 
  filter(session_id %in% c(7392233, 7392875 , 7397497))

```

שימו לב שבשבאחד המקרים השתמשנו במספר תנאים לוגיים ששולבו יחד. כשנרצה לבצע סינונים מורכבים נוכל לצרף כמה וכמה תנאים לכדי פעולה לוגית שתשאיר רק את השורות שאנחנו מעוניינים בהן.

למשל, בקטע הבא אנחנו שומרים רק נבדקים שעומדים לפחות באחד משני התנאים:
1) נשים שעברו את מבחני הקשב
2) גברים - בין אם עברו את מבחני הקשב או לא

```{r}
filtered_table = need_for_cognition %>% 
  filter(gender == "male" | (gender == "female" & attention_check ==1))
```


`תרגיל` : סננו את הקובץ כך שיכיל רק תצפיות של נשים מעל גיל 30 וגברים מעל
גיל 25

```{r filter_exercise, exercise=TRUE, exercise.eval = FALSE,}
# גברים מעל גיל 25 ונשים מעל גיל 30 
female_or_male_by_age = need_for_cognition %>%
    filter(___________)
             
```

```{r filter_exercise-solution}
female_or_male_by_age = need_for_cognition %>%
    filter() #***
```

```{r filter_exercise-check}
grade_this_code() 
```



#### ערכים חסרים

בעבודה עם נתוניים אמיתיים, שנאספו בניסוי או בסקר, במקרים רבים אנחנו נתקל
בנתונים חסרים. החוסר יכול לנבוע מכך שנבדק פספס שאלה מסוימת או נפסל באחד
הסבבים של מטלה, או שהייתה בעיה כלשהי בשמירת הנתונים שלו יהיו מקרים בהם
החוסר יגרור פסילה של שורות שלמות מהנתונים שלנו, אך לא תמיד נרצה לוותר
לגמרי על שורות שלמות בגלל כמה נתונים חסרים. כשהנתון החסר קריטי אין לנו
הרבה ברירה מלבד למחוק את השורה כולה, אך לפעמים נעדיף להשאיר אותה והשתמש
בה בניתוחים בהם יש לתצפית זו מספיק נתונים כדי להיות שימושית.

במידה ונבחר למחוק את השורה, נוכל לעשות זאת באמצעות הפונקציה drop_na.

להלן מספר דוגמאות:

```{r e8, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = nfc

# פונקציה זו מקבלת את שמות העמודות שעל בסיסן נרצה להשמיט את הנתונים.
# בדוגמה זו השמטנו שורות  בהן הערך בעמודת המגדר היה חסר
table2 =  table1 %>% drop_na(gender)
nrow(table2)

# באותו האופן, ניתן להשמיט שורות שיש בהן ערך חסר *בעמודה אחת לפחות* מתוך העמודות שציינו
table3 =  table1 %>% drop_na(gender, nfc_01, nfc_02r, nfc_03r)
nrow(table3)

# או להשמיט שורות שיש בהן תצפית חסרה כלשהי, בעמודה כלשהי
table4 = table1 %>% drop_na()
nrow(table4)



```

ברוב המקרים אנחנו נרצה למחוק את השורות עם הערכים החסרים או להשאיר את
הערכים החסרים כפי שהם ולהתעלם מהם בניתוחים שמערבים רותם, אך לפעמים נרצה
לשמור את אותן שורות ולמלא את הערכים החסרים בערכים תקינים כלשהם.

במקרים כאלו אנחנו יכולים להחליף את הערכים החסרים בערך קבוע כלשהו או
ל"מלא" את הערכים החסרים בערכים מהשורה מעל או מתחת לערך החסר.

לדוגמא:

```{r e9, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = nfc

# 
table2 = table1 %>% replace_na(list(gender= "other")

#
fill(direction = "up")


```

#### ערכים כפולים

לעיתים, במיוחד כשאנחו עוסקים במידע שצורף ממספר מקורות שונים הטבלאות שלנו
עלולות להכיל כפל של נתונים. ייתכן, למשל, ששילבנו יחד שני קבצים שבשניהם
הופיעה אותה תצפית. לטובת מקרים כאלו קיימת הפקודה distinct)(, שתפקידה
לסנן תצפיות כפולות. הפונקציה תקח את הטבלה שלנו, תעבור על כל השורות ותמחק
שורות שמהוות כפילות.

בברירת המחדל, הפונקציה תמחק רק תצפיות המהוות כפילות מוחלטת - תצפיות בהן
כל הערכים בכל העמודות זהים בין השורות. במטידה ואנחנו מעוניינים בסינון של
כפילויות חלקיות אפשר לעשות זאת באמצעות ציון שמות העמודות על בסיסן נרצה
לסנן.

להלן מספר דוגמאות:

```{r e10, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}
# בקובץ המקורי אין כפילויות, ולכן נייצר טבלה עם מספר כפילויות לצורך ההדגמה
table1 = nfc[c(1:1000,36,207,6),]

nrow(nfc) # מספר השורות לפני מחיקת כפילויות

table2 = nfc %>%
  distinct()

nrow(table2) # מספר השורות אחרי מחיקת כפילויות

# מחיקת כפילויות על בסיס עמודות מסוימות בלבד
# הפונקציה תשמור את השורה הראשונה מתוך השורות שיחשבו ככפילות
table3 = nfc %>%
  distinct(session_id, .keep_all = TRUE) # ללא התוספת בסוף הפונקציה התוכנה תחזיר טבלה המכילה רק את העמודות שצוינו

```

### פונקציות נוספות

#### rename

חבילת dplyr מספקת לנו גם דרך פשוטה לשנות את שמות העמודות שלנו. כמו כל
הפונקציות הקודמות שפגשנו, גם כאן הפונקציה *אינה עורכת* את הטבלה המקורית,
אלא מייצרת עותק ערוך שלה אותו נצטרך לשמור. הפונקציה מקבלת פירוט של השמות
החדשים שנרצה לתת לעמודות בליווי שמן הנוכחי.

```{r e11, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = nfc

table2 = nfc %>%
  rename(subject  = session_id,
         sex = gender)
        #new_name = old_name

names(table2)

```

#### Arrange

פונקציה נוספת העשויה לעזור לנו בסידור הנתונים שלנו היא הפונקציה arrange.
פונקציה זו תחזיר נו את הטבלה כשהיא מסודרת בסדר עולה או יורד על פי עמודה
אחת או יותר. הפונקציה תסדר וקטורים מספריים לפי סדר הערכים ווקטור המכיל
תווים לפי סדר הא' ב'.

במידה ונרצה להפוך את סדר המדרג נוכל להשתמש בפונקציה desc()

```{r e12, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = nfc

table2 = table1 %>%
  arrange(age)    # סידור לפי גיל

table3 = table1 %>%
  arrange(desc(session_id))  # סידור לפי מספר הרצה, בסדר יורד

table4 = table1 %>% 
  arrange( gender, age)  # סידור לפי מגדר - ואז לפי גיל

```

## עריכת נתונים

הפעולות העיקריות שנעשה בניתוח נתונים כוללות עריכה של הנתונים עצמם. כדי
שנוכל לערוך את המבחנים הסטטיסטיים שמעניינים אותנו או לייצר תרשימים
רלוונטיים נצטרך להפיק מהנתונים הגולמיים שלנו מדדים, ,לסכם אותם ולחבר
אותם עם נתונים נוספים.

בפרק הנוכחי נעבור על הפעולות הבסיסיות שנדרשות מאיתנו כחלק מתהליך זה

### חישוב עמודות - mutate

הפונקציה הנפוצה ביותר בתהליך עיבוד הנתונים היא הפונקציה mutate. פונקציה
זו מאפשרת לנו להגדיר עמודות חדשות או לערוך עמודות קיימות - באופן דומה
לעריכה שעשינו באמצעות פקד ה\$. בשילוב עם מספר פונקציות בסיסיות, פונקציית
הmutate מאפשרת לנו לערוך אתהעמודות שבטבלה שלנו במגוון רחב של דרכים.
הפונקציה מאפשרת לנו לערוך מספר עמודות בבת אחת, כאשר החישוב של כל עמודה
מופרד בפסיק ממשנהו.

להלן מספר דוגמאות:

```{r e13, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = nfc

table2 = table1 %>%
  mutate(nfc_02 = 6 - nfc_02r,  # נהפוך את הקידוד של שלושת העמודות ההפוכות
         nfc_03 = 6 - nfc_03r,
         nfc_06 = 6 - nfc_06r,
         # נחשב את ממוצע ששת השאלות.
         # שימו לב - אפשר להשתמש בעמודות שיצרנו מוקדם יותר בתוך אותה הפונקציה
         nfc    = (nfc_01 + nfc_02 + nfc_03 + nfc_04 + nfc_05 + nfc_06)/6,
         
         age_above_18 = age >=18,  # האם הנבדק מעל גיל 18
         
         gender = recode(gender, "male" = "M", "female" = "F"), # דריסת עמודת המגדר וקידודה מחדש 
                     # פונקציה זו מאפשר לנו לקודד מחדש עמודות עם מספר רמות - להחליף את הערכים המייצגים קבוצות שונות 
         
         # תקנון ציוני המדד ויצירת ציוני תקן - באופן שמתעלם מערכים חסרים
         nfc_Z_score = (nfc - mean(nfc,na.rm = T)) / sd(nfc, na.rm = T)  
         
         )
# שימו לב לסוגריים - כל העמודות שיצרנו בוכנסו בתוך פונקצייה אחת, בה הפרדנו את ההתייחסות לכל עמודה בפסיקים.
# ירידת השורה בין עמודה לעמודה נועדה כדי לשמור על הסדר ואינה נדרשת בשביל תקינות הקוד
```

דרך פונקציה זו נוכל גם לעדכן את סוג העמודות (מספרי, תווים, ערכים לוגיים,
פקטור), לחלק לקבוצות על סמך ערך מספרי או לערוך עמודות על פי תנאי

```{r e14, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-table2"}

table3 = nfc %>% #*
  mutate(gender_factor = factor(gender),             # יצרנו גרסת פקטור של נתוני המגדר
         gender_numeric = as.numeric(gender_factor), # יצרנו עמודה מספרית על סמך העמודה הקודמת (תכיל 0 ו1)
         
         # * delete
         age_category = cat(age,                     # יצירת עמודת קבוצות גיל
                            breaks = c(0,18,30,50,120),
                            labels = c("youth","young adult","adult","senior")),
         
         # במידה וגילינו שנפלה טעות ונתוני הגיל של הנשים במדגם שלנו קטנים ב5 מהערכים האמיתיים
         # נרצה לערוך רק את נתוני הגיל של נשים. הפונקציה הבאה מאפשרת לנו לבצע עריכה שכזו
         corrected_age = ifelse(gender == "F",
                                age+5 , # ערכנו את נתוני הגיל של נשים
                                age)    # והשארנו את נתוני הגיל כפי שהם עבור מי שאינו אישה
         )
```

### שימוש בפרמטרים קבוצתיים

באחת הדוגמאות הקודמות חישבנו את ציוני התקן במדד הnfc. לצורך החישוב
נעזרנו בפונקציות המחשבות את ממוצע המדד וסטיית התקן שלו. פונקציות אלו
מחשבות את הממוצע וסטיית התקן על פני כל התצפיות שלנו, ולכן הן מתאימות
לחישוב של ציוני התקן הכלליים.

ייתכן והקובץ שלנו יכיל נתונים מכמה קבוצות שונות, ונרצה לתקנן כל קבוצה
בנפרד. למשל - יכול להיות שאנחנו מעוניינים לבחון את התפלגות ה\*\*\* .
במקרים כאלו נצטרך להורות לתכנה לבצע את חישוב הממוצע וסטיית התקן לכל
קבוצה בנפרד. הפונקצייה שתשמש אותנו לשם כך נקראת group_by.

פונקציה זו מקבלת טבלה ומחזירה לנו טבלה שנראית זהה בדיוק, אך היא מוגדרת
כך שכל פעולה קבוצתית שנעשה תיעשה לפי הקבוצות שהגדרנו. אם נרצה לבטל את
החלוקה לקבוצות נצטרך לבצע זאת באמצעות פעולה מפורשת.

לפניכם מספר דוגמאות \*\*

```{r  ee14, exercise=TRUE, exercise.eval = FALSE,}

x = 1

```

## סיכום נתונים

המקרה הנפוץ יותר בו נרצה לחשב את ממוצעי הקבוצות בנפרד יהיה עבור סיכומי
נתונים. למשל - אחרי שחישבנו את ציון הnfc עבור כל נבדק, נרצה לחשב את
הממוצע וסטיית התקן במדד זה במדגם שלנו. במקרים כאלו ניעזר באותה הפונקציה
כדי לקבץ את הנתונים לקבוצות, ואחריה נשתמש בפונקציה summarise כדי להפיק
את הסיכומים שאנחנו צריכים. כמו mutate, גם פונקציה זו יודעת לחשב מספר
מדדים בתוך פונקציה אחת, אותם נפריד בפסיק. הפלט של הפונקציה יהיה טבלה,
המכילה עמודה אחת לכל סיכום שביקשנו מהפונקציה להפיק בנוסף לעמודות עבור
המדדים שעל פיהם קיבצנו את הנתונים. מספר השורות בטבלה זו יהיה קטן יותר
מאשר בטבלה המקורית שלנו, שכן כל קבוצה תיוצג על ידי שורה אחת בלבד.

להלן דוגמה:

```{r summary11, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-table2"}

summary_table = table2 %>% 
  group_by(gender)%>%
  summarise(mean_nfc = mean(nfc, na.rm = T),# חישוב ממוצע המדד עבור כל קבוצה
            sd_nfc   = sd(nfc,na.rm = T),   # חישוב סטיית התקן עבור כל קבוצה
            n_total = length(nfc),          # ספירת כלל התצפיות
            n_subjects = sum(!is.na(nfc)),  # ספירת התצפיות שאינן חסרות
            n_na = sum(is.na(nfc))          # ספירת התצפיות החסרות
  )

print(summary_table)
```

שימו לב - מאחר ועמודת המגזר שלנו מכילה ערכים חסרים, התוכנה התייחסה אליהם
כאל קבוצה נוספת וחישבה את מדדי הסיכום גם עבורם.

```{r numeric_q1, echo = FALSE}
question_text(
  "<div style='direction: rtl;'> מה היה ממוצע מדד nfc אצל הנשים במדגם? </div>",
         answer("3.15", correct = TRUE),
         allow_retry = TRUE
)
```

```{r numeric_q2, echo = FALSE}
question_text(
  "<div style='direction: rtl;'> כמה תצפיות חסרות היו במדד הnfc אצל גברים? </div>",
         answer("14", correct = TRUE),
         allow_retry = TRUE
)
```

```{r numeric_q3, echo = FALSE}
question_numeric(
  "<div style='direction: rtl;'> כמה נבדקים יש בקובץ שערך המגדר שלהם חסר, אבל הציון שלהם במדד nfc תקין? </div>",
         answer("23", correct = TRUE),
         allow_retry = TRUE
)

```

בדוגמה הקודמת סיכמנו על סמך עמודה אחת בלבד. במידה ונרצה לסכם לפי תתי
קבוצות ממספר עמודות (למשל - גברים מבוגרים, גברים צעירים, נשים מבוגרות
ונשים צעירות), נוכל להכניס עמודות נוספת לפונקציית הgroup_by

השלימו את הקוד הבא בהתאם להערות

```{r summary2, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-table2"}

summary_table2 = table2 %>% 
  # נייצר עמודה נוספת המבחינה בין נבדקים מעל ומתחת לגיל 30
  mutate(over_30 = ifelse(age >30,"over 30","30 or under")) 
  group_by(gender, over_30)%>%
  summarise(n_observations =                , #  (כולל ערכים חסרים)מספר התצפיות  הכולל בתת הקבוצה
            mean_nfc =                      , #  ממוצע ציון המדד, תוך התעלמות מערכים חסרים
            percent_attention_valid =         # אחוז הנבדקים שעברו את מבחן הקשב (ציון 1 ולא 0)
  )

print(summary_table2)
```

## צירוף נתונים

הנושא הבא שנתעסק בו כולל צירוף של נתונים מכמה טבלאות שונות. לא נדיר
שבמחקר בפסיכולוגיה אנחנו נדרשים לצרף יחד נתונים מכמה מקורות. למשל -
ייתכן ונריץ ניסוי שבו הנבדקים משתתפים במטלה קוגנטיבית כלשהי ובסופה
ממלאים מספר שאלונים. בניתוח של נתונים כאלו נרצה להפיק לכל נבדק ציונים
במדדים שונים על בסיס תשובותיהם בשאלונים ולחבר אותן יחד עם מדדים הקשורים
בביצועים שלהם במטלה. דוגמה נוספת היא מצב בו יש לנו נתונים מאותו המחקר
בכמה קבצים שונים, כיוון שהוא נערך על ידי כמה מעבדות / בכמה עמדות שונות.

ישנם כמה צורות שונות בהן נוכל לחבר את קבצי הנתונים שלנו:

1)  צירוף טבלאות

2)  הצלבת תצפיות


### צירוף טבלאות

במידה ויש לנו 2 טבלאות אם אותן עמודות, אך עם תצפיות שונות - נוכל לאחד את
השורות מהטבלאות השונות לכדי טבלה אחת ארוכה. אפשר לחשוב על פעולה זו כאל
הדבקה של השורות מטבלה אחת בסופה של הטבלה השנייה.

![](images/rbind.JPG){width="500"}

הפונקצייה שתשמש אותנו לשם כך נקראת bind_rows.

להלן דוגמה:

```{r e115, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-rbind"}

print(df_partial1)
print(df_partial2)


full_df =  bind_rows(df_partial1, df_partial2)

```

במידה וישנן עמודות שקיימות רק באחת מהטבלאות, הפונקצייה תמלא את עמודה זו בערכים חסרים עבור כל התצפיות של הטבלה השנייה


```{r e116, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-rbind"}

df_partial1_with_a = df_partial1 %>% mutate(extra_col = "a")

# הוספנו עמודה נוספת לאחת הטבלאות, שלא קיימת בטבלה השנייה
full_df_with_na = bind_rows(df_partial1_with_a, 
                            df_partial2)

```

באופן דומה - ניתן גם לצרף עמודות מטבלאות שונות. הפעם נצטרך שהטבלאות יהיו
באותו האורך, והצירוף שלהן "ידביק" אותן זו לצד זו.

![](images/cbind.JPG){width="500"}

```{r e16, exercise=TRUE, exercise.eval = FALSE , exercise.setup = "prepare-rbind"}

print(df_first_columns)
print(df_last_columns)

full_df =  bind_cols(df_first_columns, df_last_columns)


```

### הצלבת תצפיות

צירוף שורות או עמודות הוא צירוף "טיפש", כלומר - הוא לא לוקח בחשבון את
התוכן של הטבלאות. הוא גם מתבסס על ההנחה שהטבלאות מסודרות באופן זהה, כך
שהדבקה פשוטה שלהן זו לצד זו, או זו אחרי זו, תייצר טבלה קוהרנטית.

במקרים רבים נרצה להצליב ולצרף נתונים מטבלאות שאינן דווקא בעלות מבנה זהה.
ציינו דוגמה שכזו בתחילת הפרק - הצלבה של נתוני שאלונים עם תוצאות במטלה.
בשביל צירוף כזה אנחנו נצטרך לצרף את הנתונים על סמך סימן מזהה כלשהו -
למשל, על סמך מספר נבדק. אנחנו נרצה שהתוכנה תעבור על הקבצים, תמצא תצפיות
בעלות אותו מספר נבדק ותשלב אותן יחד.

למעשה, יש כמה דרכים שבהן אפשר לבצע את הפעולה הזו.


![](images/join.JPG){width="500"}


האפשרויות שלנו הן:

1)  להשאיר טבלה אחת כפי שהיא, ולצרף אליה את התצפיות המתאימות מהטבלה
    השנייה. כדי לבצע חיבור שכזה נשתמש בפונקציות `left join` או `right_join`.


2)  להשאיר את כל התצפיות משתי הטבלאות ולמלא את הטבלה בערכים חסרים בשורות
    בהן אין התאמה בין הטבלאות. פעולה זו שומרת על כל התצפיות משתי הטבלאות ומתבצעת באמצעות הפונקציה `full_join`


3)  לשמור אך ורק את התצפיות שנמצאות בשתי הטבלאות. במקרה הזה אנחנו לא נוסיף ערכים חסרים לטבלה, אבל נשמיט את כל התצפיות שנמצאות רק בטבלה אחת מתוך השתיים. הפוהקציה `inner_join` מבצעת את פעולה זו. 


הדגמה:

```{r}

# נייצר נתונים פיקטיביים

df1 = data.frame(subject_id = c(1:5),
                 age = c(22,25,20,31,40),
                 gender = c("M","F","F","M","F"))

df2 = data.frame(subject_id = c(3,2,4,6,5),
                 task_score = c(120,87,113,94,250))

print(df1)
print(df2)

# הוספת תוצאות המטלה מהטבלה השנייה לתצפיות בטבלה הראשונה

df1_2 = left_join(df1, df2, by = "subject_id")
print(df1_2)

# הוספת נתוני הגיל והמגדר לתצפיות בטבלה השנייה

df2_1 = right_join(df1, df2, by = "subject_id")
print(df2_1)

# שילוב מלא של שתי הטבלאות

df_full = full_join(df1, df2, by = "subject_id")
print(df_full)

# הצלבה בין התצפיות המופיעות בשתי הטבלאות והשמטת יתר התצפיות

df_inner = inner_join(df1, df2, by = "subject_id")
print(df_inner)

```


### צירוף על סמך מספר עמודות

ישנם לא מעט מקרים בהם נרצה לצרף נתונים על סמך יותר מעמודה אחת. למשל, אם יהיו לנו נתונים על מצב הרוח של נבקים שונים בימים שונים, ייתכן ונרצה לצרף לטבלה את ההישגים של הנבדק באותו היום. צירוף כזה ידרוש מאיתנו לצרף את הטבלאות על סמך זהות הנבדק והיום הרלוונטי. 

כדי לבצע צירוף כזה נעביר לפונקציה וקטור של שמות העמודות שעל פיהן נרצה שהצירוף יתבצע.

למשל:


```{r}

# נייצר נתונים פיקטיביים

df1 = data.frame(subject_id = c(1,1,1,2,2,2,3,3,3),
                 day        = c(1,2,3,1,2,3,1,2,3),
                 score      = c(2,7,5,6,9,8,1,4,5))

df2 = data.frame(subject_id = c(1,2,3,1,2,3,1,2,3),
                 day        = c(1,1,1,2,2,2,3,3,3),
                 mood       = c(1,7,9,3,4,6,2,7,8))

print(df1)
print(df2)
# שילוב מלא של שתי הטבלאות

df_full = full_join(df1, df2, by = c("subject_id","day"))
print(df_full)

```



### כפילויות

אחת התקלות הנפוצות בצירוף טבלאות נוגעת למצבים בהם אנחנו מנסים לצרף נתונים המכילים כפילויות בעמודות שעל בסיסן אנחנו מבקשים לחבר את הטבלאות. כל עוד **רק באחת הטבלאות** יש כפילות שכזו - התכנה תשכפל את התצפיות מהטבלה השנייה ותבצע את הצירוף בהצלחה.

למשל:

```{r}

# נייצר נתונים פיקטיביים

df1 =data.frame(subject_id = c(1,1,1,2,2),
                day        = c(1,2,3,1,2),
                task_score = c(120,87,113,94,250)) 

df2 = data.frame(subject_id = c(1,2,3),
                 age = c(22,25,20),
                 gender = c("M","F","F"))

print(df1)
print(df2)


# הוספת הנתונים הדמוגרפיים מהטבלה השנייה לתצפיות בטבלה הראשונה

df1_2 = left_join(df1, df2, by = "subject_id")
print(df1_2)

# שילוב מלא של שתי הטבלאות

df_full = full_join(df1, df2, by = "subject_id")
print(df_full)
```

שימו לב שהנתונים הדמוגרפים שנוספו לטבלה (גיל ומגדר) הינם זהים בין השורות השונות של אותו הנבדק.




מנגד - כשבשתי הטבלאות יש כפילות, **אין לתכנה מספיק מידע כדי להצמיד בין התצפיות** ולכן היא תעלה הודעת שגיאה.


```{r}

# נייצר נתונים פיקטיביים

df1 =data.frame(subject_id = c(1,1,1,2,2),
                day        = c(1,2,3,1,2),
                happiness  = c(100,65,80,95,90)) 

df2 = data.frame(subject_id = c(1,1,2,3),
                 task       = c(1,2,1,1),
                 task_score = c(80,85,90,93))
                 
# הוספת תוצאות המטלה מהטבלה השנייה לתצפיות בטבלה הראשונה

df1_2 = left_join(df1, df2, by = "subject_id")

```


## שינויי צורה

הנושא האחרון שנעסוק בו בעריכת נתונים הוא שינויים **במבנה** הטבלאות. שינויים אלו לא עורכים את התוכן המיוצג בטבלה, אלא רק את האופן בו הנתונים מסודרים.

מקובל להתייחס לשני פורמטים: פורמט רחב ופורמט ארוך

פורמט רחב מכיל עמודות נפרדות המייצגות ערכים דומים תחת תנאים שונים. כשיש לנו מספר תנאים - יהיו כמה וכמה עמודות, ולכן הטבלה תהיה רחבה. למשל, בטבלה הבאה אנחנו מציגים את התוצאות של ארבעה נבדקים בשני חזרות שונות של אותה המטלה - בפורמט רחב.

```{r}
print(wide_df)
```

העמודות "first" ו"second" מתארות את הישגי הנבדקים בחזרה הראשונה והשנייה של המטלה. אם היינו מוסיפים נתונים מחזרה שלישית, רביעית וכו' הטבלה הייתה הולכת ונהיית רחבה יותר, בהתאם לכך שהוספנו אליה עוד ועוד עמודות.


בפורמט ארוך אותם נתונים יראו כך:

```{r}
print(long_df)
```


כאן יש לנו עמודה אחת המכילה את הערכים (הציון במטלה) ועמודה נוספת המציינת באיזו חזרה מדובר (ראשונה או שנייה). במידה והיינו מוסיפים נתונים מחזרות נוספות - הטבלה הייתה נהיית **ארוכה** יותר.


#### מה עדיף?

ובכן, התשובה תלויה בשימוש שאנחנו רוצים לעשות בנתונים. יהיו מקרים בהם פורמט רחב יהיה לנו יותר נח - למשל אם אנחנו רוצים לחשב את ההפרש בביצועים בין החזרה הראשונה והשנייה של המטלה עבור כל נבדק, ויהיו מקרים בהם דווקא פורמט ארוך יהיה עדיף. 

כפועל יוצא מכך, לא נדיר שאנחנו צריכים להמיר את הטבלאות שלנו מפורמט אחד לפורמט האחר. למזלנו - ישנו צמד פונקציות שמאפשר לנו לעשות זאת יחסית בקלות.


### spread - פורמט ארוך לפורמט רחב

הפונקציות בהן נשתמש אינן חלק מהחבילה `dplyr`, אלא מחבילה הנקראת `tidyr`. ניתן לייבא את שתי החבילות יחד באמצעות ייבוא של מאגר חבילות בשם `tidyverse`.

השימוש בפונקציות אלו הוא די פשוט. בנוסף לטבלה עצמה (אותה ניתן להעביר לפונקציה באמצעות פקד העברה) הפונקציות צריכות לקבל מאיתנו :

1)key:
  שם העמודה המכילה את המפתחות - החלוקה לפיה אנחנו מעוניינים להפריד את הערכים למספר עמודות שונות. בדוגמה הקודמת קראנו לעמודה זן "iteration" והיא הכילה את הערכים "first" ו"second".
  
2) value:
  שם עמודה המכילה את הערכים עצמם. בדוגמה הקודמת קראנו לעמודה זו "score".

לדוגמה:

```{r}
library(tidyverse)

wide_df = long_df %>%
  spread(key = "iteration", value = "score")

```


נתובנן בדוגמה נוספת. הפעם הנתונים (הפיקטיביים) מתארים את ציוני הIQ של בני משפחה שונים.  

```{r}

print(long_df2)


wide_df2 = long_df2 %>%
  spread(key = "familial_role", value = "IQ")

print(wide_df2)

```


שימו לב: מאחר והטבלה הארוכה לא הכילה ייצוג עבור כל תפקיד בכל אחת מהמשפחות - בטבלה בפורמט רחב ישנם ערכים חסרים



### פורמט רחב לפורמט ארוך


הפוהקציה `gather` מבצעת את הפעולה ההופכית לפונקציה שראינו עכשיו. היא מקבלת טבלה בפורמט רחב ומאגדת את חלק מהעמודות שלה יחד לכדי פורמט ארוך.

כמו קודמתה, גם היא מקבלת פירוט של שם עמודת המפתחות (key) ועמודת הערכים (value), אך מאחר ועמודות אלו עוד לא קיימות - הערכים שנזין כאן ישמשו כדי לקבוע את הכותרות עבור עמודות אלו. בנוסף לערכים אלו, הפונקציה צריכה לקבל פירוט של העמודות אותן נרצה לקבץ.

למשל:

```{r}
library(tidyverse)

long_df  = wide_df  %>%
  gather(key = "iteration", value = "score", first, second)

```

שורות הקוד האלו הופכות את הטבלה שיצרנו מוקדם יותר חזרה לפורמט רחב. התכנה תיקח את העמודות "first" ו"second" ותייצר מהן עמודה אחת בשם "iteration" המכילה את המפתחות, ועמודה נוספת בשם "score" שתכיל את הערכים עצמם.

במידה ולא היינו מציינים את שמות העמודות שרצינו לאחד - הפונקציה הייתה מקבצת את כל העמודות יחד, ובכלל כך גם את העמודה "subject". כדי למנוע זאת ציינו את העמודות הספציפיות אותן נרצה לקבץ. יכולנו לבצע את אותה הפעולה באמצעות הכתיב הבא:

```{r}

long_df  = wide_df  %>%
  gather(key = "iteration", value = "score", -subject)

```

הפעם, במקום לציין אלו עמודות לקבץ - ביקשנו שהפונקציה תקבץ את כל העמודות למעט העמודה המכילה את זהות הנבדקים. 


`תרגיל:`
הטבלה "mood" מכילה מדידות מצב רוח (0 - נמוך, 10 - מרומם) בבוקר, צהריים וערב, עבור 20 נבדקים.

חשבו את ההפרש במצב הרוח בין הבוקר לצהריים ובין הצהריים לערב עבור כל נבדק. היעזרו לשם כך בשינוי פורמט הטבלה כך שכל מדידה תיוצג באמצעות עמודה נפרדת.

לאחר מכן, צרו טבלה חדשה המכילה עבור כל נבדק את מספר הנבק ואת שתי עמודות ההפרשים שיצרתם והמירו אותה לטבלה בפורמט ארוך (שימו לב לשמור על עמודת מספרי הנבדקים מחוץ לקיבוץ העמודות).


שלפו את העמודה המכילה את ערכי ההפרשים מהטבלה החדשה שיצרתם (באמצעות פקד ה`$` או הפונקצייה `pull`) ושמרו אותה בשם "mood_diffs".


מומלץ להתעיק את הקוד לRstudio, לעבוד עליו בסביבת העבודה של התוכנה ולהעתיק חזרה את הקוד הסופי כשהוא מוכן.

```{r exercise_gather, exercise=TRUE, exercise.eval = FALSE, exercise.cap = "יצירת טבלה", }

# בררו את שמות העמודות באחד האופנים שנלמדו בשיעור הקודם


# המירו את הטבלה לפורמט רחב וחשבו את ההפרשים בציוני מצב הרוח
wide_mood = __________________


# חתכו טבלה חדשה המכילה רק את ציוני ההפרשים ואת המספר המזהה של כל נבדק
# והמירו את הטבלה לפורמט ארוך

long_mood_diff = ____________


mood_diffs = _____________

```

```{r exercise_gather-check}

solution1 = mood %>% spread(key = "measurement_time",   # to wide
                value = "mood_score") %>%
  mutate(noon_to_morning = noon - morning,              # calc diffs
         eve_to_noon = evening - noon) %>%
    
  select(- evening, - morning, - noon) %>%              # select only diff columns
  gather(key = "times", value = "diff", -subject) %>%   # to long 
  
   pull(diff) # pull values


solution2 = mood %>% spread(key = "measurement_time", # to wide
                value = "mood_score") %>%
  mutate(eve_to_noon = evening - noon,
         noon_to_morning = noon - morning, # calc diffs
         ) %>%
    
  select(- evening, - morning, - noon) %>% # select only diff columns
  gather(key = "times", value = "diff", -subject)  %>% # to long 
  pull(diff) # pull values


grade_result(
  pass_if(~identical(.result$mood_diffs, solution1) || identical(.result$mood_diffs, solution2)
          ))

```



## הגשה
  עברו על הקובץ וודאו שהגשתם את כל התרגילים ועניתם על כל השאלות
  
  במידה וכל התשובות שלכם תקינות יש ללחוץ על הכפתור:  Generate, להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```


