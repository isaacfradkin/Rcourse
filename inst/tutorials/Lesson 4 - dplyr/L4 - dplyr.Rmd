---
title: "Lesson 3: Dataframes" 
output:

  learnr::tutorial:
    progressive: true
    allow_skip: false

     
runtime: shiny_prerendered  

---

<!-- the above should be in the beginning of each lesson -->

<!-- code to format so all text appears rtl (Hebrew) -->

```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>

```
<!-- tutorial options and cheching options - TODO set params -->

```{r setup, include=FALSE}
library(learnr)

tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)


knitr::opts_chunk$set(error = TRUE)
#gradethis::gradethis_setup()
```


```{r prepare-df1}
nycflights <- nycflights13::flights
```


## dplyr מבוא

בשיעור זה נלמד להשתמש במגוון רחב של פונקציות המאוגדות תחת החבילה dplyr.

פונקציות אלו מאוד נפוצות בשימוש בR כיוון שהן מאפשרות למו לעבד קבצי נתונים במספר רב של דרכים באופן פשוט ומסודר. בחלק מהמקרים הפונקציות שנפגוש יאפשרו לנו לעשות דברים שכבר למדנו איך לעשות באופנים אחרים (משל - חיתוך של שורות או עמודות) אך הן יעשו זאת באופן שיאפשר לנו לשמור את הקוד שלנו קריא ותמציתי. במקרים אחרים נפגוש פונקציות שמאפשרות לנו לעשות עיבודים חדשים שעוד לא פגשנו.

השיעור ארוך יותר מהשיעורים הקודמים, אך הוא נוגע בתחום מרכזי מאוד בשימוש בתוכנה ולכן מומלץ להקדיש לו זמן וקשב. ברוב הדברים שנלמד השיעור אתם תעשו שימוש נרחב בכל פעם שתנתחו נתונים.

### פקד ההעברה

לפני שנגיע לשימוש בפונקציות עצמן, נרצה להתעכב על פקד חדש - פקד ההעברה (או באנגלית - piping).
פקד זה מיוצג על ידי הסימון %>% ואפשר לחשוב עליו כעל צינור שמעביר את מה שלפניו לפונקציה שאחריו.

למשל, בדוגמה הבאה הפקד מעביר את הוקטור X לתוך הפונקציה mean(). שימו לב - זה נראה כאילו השארנו את הפונקציה ריקה, אך בעצם העברנו לתוכה את הוקטור, כך שהחישוב יעשה עליו. הקוד בשורות אלו מקביל לקוד שמופיע בשורה הבאה.

במידה ונרצה לתת לפונקציה ארגומנטים נוספים, כפי שקורה בדוגמה הבאה, נוכל לפרט אותם בתוך הסוגריים של הפונקציה. גם כאן, השורה הבאה מראה לנו את אותה הפקודה בכתיב שלא כולל את פקד ההעברה.


*

למה זה טוב?

כל עוד אנחנו משתמשים בפונקציה אחת, אין לשימוש בפקד זה שום יתרון אמיתי. היתרון העיקרי מגיע כשאנחנו רוצים להשתמש בכמה פונקציות ברצף. במקרים כאלו, אנחנו יכולים להכניס את התוצר של כל פונקציה בתוך הפונקיה הבאה, אבל כתיב כזה ייצר קוד מאוד מסורבל. במקרים כאלו הפקד מאפשר לנו לכתוב א תאותו הקוד באופן הרבה יותר מסודר ונח לקריאה. נוכל גם לרווח את הקוד לשורות שונות ולהוסיף הערות שיעזרו לנו לזכור את המטרה של כל שלב בניתוח.

שימו לב - תוצרי הביניים של הפונקציות לא נשמרים במקרה כזה. התוצר היחיד שישמר הוא האובייקט שייצרנו אחרי ההעברה בכל הפונקציות, והוא יישמר תחת שם האובייקט שאליו ביצענו את ההשמה (במקרה הזה - *).

נסו לכתוב את הקוד שלמטה באמצעות פקדי העברה. שימו לב לשמור את הקוד ברור ומסודר.

מה לדעתכם עושה כל אחת מהפונקציות? התשובות מופיעות תחת כפתור הרמז

**




## בחירת עמודות, סינון שורות וסידור טבלאות

כעת ניגש לפונקציות של חבילת dplyr. הפונקציות הראשונות בהן נשתמש מבצעות פעולות שכבר התנסנו בהם. למשל - הפונקציה select() מאפשרת לנו לייצר טבלה חדשה מתוך העמודות של טבלה קיימת. אנחנו יכולים לציין את שמות העמודות שאנחנו רוצים להשאיר - או לציין בליווי מינוס את העמודות שאנחנו רוצים לסלק.

כך או כך, הפונקציה מייצרת טבלה *חדשה* מתוך החיתוך שעשינו. היא אינה עורכת את הטבלה המקורית שהכנסנו לפונקציה. לכן - מצטרך לשמור את האובייקט שהפונקציה מחזירה כדי לקבל את הטבלה הערוכה.

במידה ואנחנו רוצים לערוך את אותה הטבלה ולא לייצר טבלה חדשה אנחנו עדיין יכולים להשתמש בפונקציה זו. כדי לעדכן את אותה הטבלה פשוט נדרוס את הגרסה הישנה (לפני השמטת העמודות) ונבצע השמה לתוך האובייקט המקורי.

להלן מספר דוגמאות:

*


יישום שימושי נוסף של פונקציה זו הוא שהיא מאפשרת לנו גם לבחור עמודות על סמך התוכן של שמות העמודות. למשל - באמצעות הפונקציה contains() נוכל לבחור את כל העמודות המכילות רצף תווים מסויים. אפשרות זו שימוש כשאנחנו רוצים לבחור קבוצה של עמודות ששמרנו בשם דומה - למשל תשובות לשאלות שונות באותו השאלון.

בדוגמה למטה אנח חותכים מתוך הטבלה הכללית שלנו תת-טבלה המכילה רק את התשובות לשאלון מסויים ואת שם המשתמש

*


שימו לב - כשנבצע בחירת עמודות באמצעות select)( נקבל חזרה טבלה - גם אם בחרנו רק עמודה אחת. במידה ונרצה לבצע חיתוך של עמודה בודדת כוקטור נוכל להיעזר בפקד ה$, או להשתמש בפקודה pull() המבצעת פעולה דומה. בדוגמה הבאה אנו נעזרים בפקודה זו על מנת לבחון מה הן הערכים השונים המוכלים בעמודה X, פעולה נפוצה כחלק מהבנת המבנה של טבלה חדשה.

ה


### filter


עכשיו שכיסינו את חיתוך עמודות - נוכל לעבור לעיסוק המשלים: סינון שורות. 
 גם כאן נוכל לבחור או להשמיט שורות לפי המספר הסידורי שלהם, באמצעות הפקודה slice() , אך ברוב המקרים סיהון השורות שנבצע יהיה תלוי בתוכן של השורות עצמם.
 
 למשל - ייתכן ונרצה לסנן מתוך קובץ הנתונים שלנו את כל הנבדקים שלא סיימו את הניסוי, או את כל הנבדקים מחוץ לטווח גילאים או אחוזי הצלחה מסויימים.
 
 בשביל פעולות כאלו, שהינן תנאי הכרחי כמעט בכל ניתוח שנערוך, אנחנו עורכים באמצעות הפונקציה filter)().
 
 פונקצייה זו מקבלת את הטבלה כאיבר ראשון או באמצעות פקד ההעברה, ותנאי לוגי שיקבע אילו שורות ישארו. תנאי זה יתבסס על עמודה אחת או יותר.
 
 להלן מספר דוגמאות:
 
 *
 
 יהיו מקרים בהם נרצה לערוך סינוך על סמך מספר קריטריונים. למשל - נרצה לשמור רק את מי שסיים את השאלון ( וגם *. במקרים כאלו  נצרף יחד מספר תנאים לוגים לתנאי אחד באמצעות הפקודות "או" (OR) המיוצג על ידי הסימן |
 ו"וגם" (AND) המיוצג על ידי הסימן &&.
 
 נסו לסנן את הטבלאות הבאות לפי ההוראות בהערות שבגוף הקוד:
 
 
 
 כשנעשה שימוש בתנאים מורכבים יותר, כדאי להשתמש גם בסוגריים. כמו כל פעולת חשבון אחרת, גם בפעולות לוגיות ישנו סדר פעולות חשבון - בהיעדר סוגריים נתחיל בפעולות ה"וגם" (&) ורק אח"כ נעבור לפעולות ה"או" (|).
 
 תרגיל: סננו את הוקבץ באמצעות פקודת filter אחת, ושמרו רק תצפיות של גברים מעל גיל 25 ונשים מעל גיל 30
 
 *
 
 
#### ערכים חסרים

עד עכשיו כל הנתונים שלנו היו שלמים, כלומר - כל המשבצות בטבלה תמיד היו מלאות במספרים תקינים. בפועל, במקרים רבים אנחנו נתקלים בנתונים חסרים. נתונים כאלו יכולים לנבוע מכך שנבדק פספס שאלה מסוימת או נפסל באחד הסבבים של מטלה, והם מהווים אתגר מורכב יחסית לניתוח הנתונים.

הבעיה העיקרית עם נתונים חסרים - הוא שאנחנו לא תמיד מודעים לקיומם **** 


#### ערכים כפולים

לעיתים, במיוחד כשאנחו עוסקים במידע שצורף ממספר מקורות שונים הטבלאות שלנו עלולות להכיל כפל של נתונים. ייתכן, למשל, שבטעות התעיקו את הנתונים של נבדק מסויים פעמיים לקובץ. לטובת מקרים כאלו קיימת הפקודה distinct)(, שתפקידה לסנן תצפיות כפולות. הפונקציה תקח את הטבלה שלנו, תעבור על כל השורות ותמחק שורות שמהוות כפילות. מחיקה זו תתבצע אך ורק כל העמושות של 2 שורות זהות, והיא תשאיר אותנו רק עם עותק אחד של אותה תצפית. )



### פונקציות נוספות


#### rename

חבילת גפךטר מספקת לנו גם דרך פשוטה לשנות את שמות העמודות שלנו. כמו כל הפונקציות הקודמות שפגשנו, כם כאן הפונקציה *אינה עורכת* את הטבלה המקורית, אלא מייצרת עותק ערוך שלה אותו נצטרך לשמור. המבנה של פונקציה זו הוא כדלהלן:



*

שימו לב שאין צורך לציין מחדש את שמות כל העמודות, אלא רק לקבוע את השמות החדשים עבור העמודות הספציפיות שנרצה לשנות להן את השם.


#### Arrange

פונקציה נוספת העשויה לעזור לנו בסידור הנתנוים שלנו היא הפונקציה arrange. פונקציה זו תחזיר נו את הטבלה כשהיא מסודרת בסדר עולה או יורד על פי אחת העמודות/ ** עובד גם על תווים

במידה ונרצה להפוך את סדר המדרג נוכל להשתמש בפונקציה desc()





## עריכת נתונים

### mutate

בסיסי, חשבון
string - גזירת אותיות, צירוף אותיות
separate?


ifelse()
שינוי סוגי עמודות
recoding, cat

mutate

פעולות לפי קבוצות (ממוצעים, נרמול וכו')

##סיכום נתונים 

group_by()
summary()

first / last
min, max, mean, quantile

## צירוף נתונים

יצירת עמודות מתאימות
כיוון הצירוף (innerjoin)
בעיות בצירוף (שינוי סוג העמודות)



