---
title: "Lesson 3: Dataframes" 
output:

  learnr::tutorial:
    progressive: true
    allow_skip: false

     
runtime: shiny_prerendered  

---

<!-- the above should be in the beginning of each lesson -->

<!-- code to format so all text appears rtl (Hebrew) -->

```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>

```
<!-- tutorial options and cheching options - TODO set params -->

```{r setup, include=FALSE}
library(learnr)

tutorial_options(
  exercise.timelimit = 60,
  # A simple checker function that just returns the message in the check chunk
  exercise.checker = function(check_code, ...) {
    list(
      message = eval(parse(text = check_code)),
      correct = logical(0),
      type = "info",
      location = "append"
    )
  }
)


knitr::opts_chunk$set(error = TRUE)
#gradethis::gradethis_setup()
```


```{r prepare-df1}
nycflights <- nycflights13::flights
```


## dplyr מבוא

בשיעור זה נלמד להשתמש במגוון רחב של פונקציות המאוגדות תחת החבילה dplyr.

פונקציות אלו מאוד נפוצות בשימוש בR כיוון שהן מאפשרות לעבד קבצי נתונים באופן פשוט ומסודר. בחלק מהמקרים הפונקציות שנפגוש יאפשרו לנו לעשות דברים שכבר למדנו איך לעשות בשיעורים הקודמים (משל - חיתוך של שורות או עמודות מתוך טבלה) אך הן יעשו זאת באופן שיאפשר לנו לשמור את הקוד שלנו קריא ותמציתי. במקרים אחרים נפגוש פונקציות שמאפשרות לנו לעשות עיבודים חדשים שעוד לא פגשנו.

השיעור ארוך יותר מהשיעורים הקודמים, אך הוא נוגע בתחום מרכזי מאוד בשימוש בתוכנה ולכן מומלץ להקדיש לו זמן וקשב, שכן אלו פונקציות שנמצאות בשימוש תדיר בעיבוד נתונים.

### פקד ההעברה

לפני שנגיע לשימוש בפונקציות עצמן, נרצה להתעכב על פקד חדש - פקד ההעברה (או באנגלית - piping).
פקד זה מיוצג על ידי הסימון %>% ואפשר לחשוב עליו כעל צינור שמעביר את מה שלפניו לפונקציה שאחריו.

למשל, בדוגמה הבאה הפקד מעביר את הוקטור scores לתוך הפונקציה mean(). כל צמד של שורות קוד (עם ובלי פקד ההעברה) מבצעים את אותה הפעולה בדיוק.

```{r e1, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

scores = c(80,75,60,94,81,72,93,52,98,62,82,90,73,75,63,82,76,97,61,75,84,80,95)

# חישוב הציון הממוצע
mean_score = mean(scores)
mean_score = scores %>% mean()

# חישוב הרבעונים
scores_quartiles = quantile(scores, probs = c(0.25,0.5,0.75))
scores_quartiles = scores %>% quantile(probs = c(0.25,0.5,0.75))


```

#### למה זה טוב?

כל עוד אנחנו משתמשים בפונקציה אחת, אין לשימוש בפקד זה יתרון משמעותי. היתרון העיקרי מגיע כשאנחנו רוצים להשתמש בכמה פונקציות ברצף. במקרים כאלו, אנחנו יכולים להכניס את התוצר של כל פונקציה בתוך הפונקיה הבאה, אבל כתיב כזה ייצר קוד מאוד מסורבל. הפקד מאפשר לנו לכתוב את אותו הקוד באופן הרבה יותר מסודר ונח לקריאה. נוכל גם לרווח את הקוד לשורות שונות ולהוסיף הערות שיעזרו לנו לזכור את המטרה של כל שלב בניתוח.  

בעיקרון, אנחנו יכולים לבצע את כל שלבי החישוב בנפרד, לשמור את התוצרים של כל פונקציה כאובייקט חדש ולהשתמש בו בפונקציה הבא - אך דרך זו היא גם יותר מסורבלת וגם "מזהמת" את סביבת העבודה שלנו עם אובייקטים מיותרים

שימו לב - כשאנחנו משתמשים בפקדי העברה תוצרי הביניים של הפונקציות לא נשמרים. התוצר היחיד שישמר הוא האובייקט שייצרנו אחרי הפנקציה האחרונה בשרשרת, והוא יישמר תחת שם האובייקט שאליו ביצענו את ההשמה - *).

בקטע הקוד הבא ישנן מספר דוגמאות ותרגיל

```{r e2, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

scores = c(80,75,60,94,81,72,93,52,98,62,82,90,73,75,63,82,76,97,61,75,84,80,95)

# חישוב הטווח הבין רבעוני

# שמירה של תוצרי הביניים כאובייקטים - מזהם את סביבת העבודה באובייקטים מיותרים
Q1_and_Q3 = quantile(scores, probs = c(0.25,0.75))  # חישוב ערכי הרבעון הראשוןם והשלישי
inter_quartile_range = diff(Q1_and_Q3)              # חישוב ההפרש בין ערכי הרבעונים
# שימוש בפונקציות שונות אחת בתוך השנייה
inter_quartile_range = diff(quantile(scores, probs = c(0.25,0.75)))
# שימוש בפקד ההעברה
inter_quartile_range = scores %>% 
  quantile(probs = c(0.25,0.75)) %>% # חישוב ערכי הרבעון הראשוןם והשלישי
  diff()                             # חישוב ההפרש בין ערכי הרבעונים


# הדפסת הציון הממוצע אחרי עיגול

print(paste("The mean score is",round(mean(scores),1)))

scores %>%
  mean()%>%                      # חישוב הממוצע
  round(1) %>%                   # עיגול הממוצע שחושב לספרה אחת אחרי הנקודה העשרונית
  paste("The mean score is",.)%>%# הדבקת התוצאה יחד עם קטע טקסט קצר
  print()                        # שימו לב: ניתן להשתמש בנקודה כדי לסמן את המיקום שבו  
                                 # נרצה להכניס את התוצר מהפונקציה הקודמת, במידה ולא מדובר
                                 # בהכרח במיקום הראשון בפונקציה


######   תרגיל  ######

# כתבו מחדש את החישוב הבא באמצעות פקדי העברה

numbers_as_text = c("12","14","15","7","34","22","17")

median_number = median(as.numeric(numbers_as_text))

median_number = _________________________________

```




## בחירת עמודות, סינון שורות וסידור טבלאות

כעת ניגש לפונקציות של חבילת dplyr. הפונקציות הראשונות בהן נשתמש מבצעות פעולות שכבר התנסנו בהם. למשל - הפונקציה select() מאפשרת לנו לייצר טבלה חדשה מתוך העמודות של טבלה קיימת. אנחנו יכולים לציין את שמות העמודות שאנחנו רוצים להשאיר - או לציין בליווי מינוס את העמודות שאנחנו רוצים לסלק.

כך או כך, הפונקציה מייצרת טבלה *חדשה* מתוך החיתוך שעשינו. היא אינה עורכת את הטבלה המקורית שהכנסנו לפונקציה. לכן - נצטרך לשמור את האובייקט שהפונקציה מחזירה כדי לקבל את הטבלה הערוכה.

במידה ואנחנו רוצים לערוך את אותה הטבלה אנחנו יכולים לשמור את הטבלה המעודכנת תחת שמה של הטבלה המקורית ובכך לדרוס את הגרסה הישנה ולהחליף אותה במעודכנת.

להלן מספר דוגמאות:

```{r e3, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

# נשתמש בטבלה שייבאנו בשיעור הקודם, המכילה את נתוני שאלון 
# need for cognition

table1 = need_for_cognition

# בחירת העמודות המציינות את מספר ההרצה, את מין הנבדק ואת הגיל שלו
demographic_data = table1 %>% select(session_id,age,gender)

# השמטת העמודה הראשונה ועמודות בדיקת העירנות
table2 = table1 %>% select(-1,-attention_check)

# עדכון הטבלה שיצרנו כך שלא תכיל את נתוני הגיל
table2 = table2 %>% select(-age)                    # אם תריצו את שורה זו פעמיים ברצף תקבלו הודעת שגיאה. נסו להבין מדוע
```



יישום שימושי נוסף של פונקציה זו הוא שהיא מאפשרת גם לבחור עמודות על סמך התוכן של שמות העמודות. למשל - באמצעות הפונקציה contains() נוכל לבחור את כל העמודות המכילות רצף תווים מסויים. אפשרות זו שימושית כשאנחנו רוצים לבחור קבוצה של עמודות ששמרנו בשם דומה - למשל תשובות לשאלות שונות באותו השאלון.

בדוגמה למטה אנח חותכים מתוך הטבלה הכללית שלנו תת-טבלה המכילה רק את התשובות לשאלון ואת המספר המזהה של התגובה של כל נבדק

```{r e4, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = need_for_cognition

questions_and_sesion_id = table1 %>% select(session_id,contains("nfc"))
                
```


שימו לב - כשנבצע בחירת עמודות באמצעות select)( נקבל חזרה טבלה - גם אם בחרנו רק עמודה אחת. במידה ונרצה לבצע חיתוך של עמודה בודדת כוקטור ולא כטבלה נוכל להיעזר בפקד ה$, או להשתמש בפקודה pull() המבצעת פעולה דומה. בדוגמה הבאה אנו נעזרים בפקודה זו על מנת לבחון מה הם הערכים השונים המוכלים בעמודה gender, פעולה נפוצה כחלק מהבנת המבנה של טבלה חדשה.

```{r e5, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = need_for_cognition

table1 %>% pull(gender) %>% # שליפת העמודה המכילה את נתוני המגדר
  unique() %>%              # פונקציה המשיבה את הערכים השונים הקיימים הוקטור
  print()                   # הדפסה

# ניתן לראות שהעמודה מכילה ערכים המעידים על נבדקים זכרים, נקבות וערכים חסרים כלשהם
                
```


### filter


עכשיו שכיסינו את חיתוך עמודות - נוכל לעבור לעיסוק המשלים: סינון שורות. 
 גם כאן נוכל לבחור או להשמיט שורות לפי המספר הסידורי שלהם, באמצעות הפקודה slice() , אך ברוב המקרים סינון השורות שנרצה לבצע יהיה תלוי בתוכן של השורות עצמם ולא במספר הסידורי שלהם.
 
 למשל - ייתכן ונרצה לסנן מתוך קובץ הנתונים שלנו את כל הנבדקים שלא סיימו את הניסוי, הנבדקים שנמצאים מחוץ לטווח גילאים מסויים או שחסרים להם נתונים חשובים.
 
 בשביל פעולות כאלו, שהינן תנאי הכרחי כמעט בכל ניתוח שנערוך, ניעזר בפונקציה filter)().
 
 פונקצייה זו מקבלת את הטבלה עליה נרצה לבצע את הסינון (באופן ישיר או באמצעות פקד ההעברה), ותנאי לוגי שיקבע אילו שורות ישארו. תנאי זה יתבסס על עמודה אחת או יותר מתוך הטבלה.
 
 להלן מספר דוגמאות:
 
```{r e6, exercise=TRUE, exercise.eval = FALSE, , exercise.setup = "prepare-df1"}

table1 = need_for_cognition

filtered_table1 = table1 %>%
  filter(attention_check == 1) # שמירת כל הנבדקים שעמדו בבדיקת תשומת הלב בניסוי

filtered_table2 = table1 %>%
  filter(age >20 & age <=30) # שמירת כל הנבדקים בין גילאי 20 ו30 (כולל)

filtered_table3 = table1 %>%
  filter( !is.na(gender)) # שמירת כל הנבדקים ש*אין* להם ערכים חסרים בעמודת המגדר

filtered_table4 = table1 %>%     # שילוב של כל התנאים הנ"ל
  filter(attention_check == 1 &
           age >20 & age <=30 &
           !is.na(gender)) 
                
```
 
 יהיו מקרים בהם נרצה לערוך סינון על סמך מספר קריטריונים. למשל - נרצה לשמור רק את מי שסיים את השאלון ( וגם *. במקרים כאלו  נצרף יחד מספר תנאים לוגים לתנאי אחד באמצעות הפקודות "או" (OR) המיוצג על ידי הסימן |
 ו"וגם" (AND) המיוצג על ידי הסימן &&.
 
 נסו לסנן את הטבלאות הבאות לפי ההוראות בהערות שבגוף הקוד:
 
 
 
 כשנעשה שימוש בתנאים מורכבים יותר, כדאי להשתמש גם בסוגריים. כמו כל פעולת חשבון אחרת, גם בפעולות לוגיות ישנו סדר פעולות חשבון - בהיעדר סוגריים נתחיל בפעולות ה"וגם" (&) ורק אח"כ נעבור לפעולות ה"או" (|).
 
 תרגיל: סננו את הוקבץ באמצעות פקודת filter אחת, ושמרו רק תצפיות של גברים מעל גיל 25 ונשים מעל גיל 30
 
 *
 
 
#### ערכים חסרים

עד עכשיו כל הנתונים שלנו היו שלמים, כלומר - כל המשבצות בטבלה תמיד היו מלאות במספרים תקינים. בפועל, במקרים רבים אנחנו נתקלים בנתונים חסרים. נתונים כאלו יכולים לנבוע מכך שנבדק פספס שאלה מסוימת או נפסל באחד הסבבים של מטלה, והם מהווים אתגר מורכב יחסית לניתוח הנתונים.

הבעיה העיקרית עם נתונים חסרים - הוא שאנחנו לא תמיד מודעים לקיומם **** 


#### ערכים כפולים

לעיתים, במיוחד כשאנחו עוסקים במידע שצורף ממספר מקורות שונים הטבלאות שלנו עלולות להכיל כפל של נתונים. ייתכן, למשל, שבטעות התעיקו את הנתונים של נבדק מסויים פעמיים לקובץ. לטובת מקרים כאלו קיימת הפקודה distinct)(, שתפקידה לסנן תצפיות כפולות. הפונקציה תקח את הטבלה שלנו, תעבור על כל השורות ותמחק שורות שמהוות כפילות. מחיקה זו תתבצע אך ורק כל העמושות של 2 שורות זהות, והיא תשאיר אותנו רק עם עותק אחד של אותה תצפית. )



### פונקציות נוספות


#### rename

חבילת גפךטר מספקת לנו גם דרך פשוטה לשנות את שמות העמודות שלנו. כמו כל הפונקציות הקודמות שפגשנו, כם כאן הפונקציה *אינה עורכת* את הטבלה המקורית, אלא מייצרת עותק ערוך שלה אותו נצטרך לשמור. המבנה של פונקציה זו הוא כדלהלן:



*

שימו לב שאין צורך לציין מחדש את שמות כל העמודות, אלא רק לקבוע את השמות החדשים עבור העמודות הספציפיות שנרצה לשנות להן את השם.


#### Arrange

פונקציה נוספת העשויה לעזור לנו בסידור הנתנוים שלנו היא הפונקציה arrange. פונקציה זו תחזיר נו את הטבלה כשהיא מסודרת בסדר עולה או יורד על פי אחת העמודות/ ** עובד גם על תווים

במידה ונרצה להפוך את סדר המדרג נוכל להשתמש בפונקציה desc()





## עריכת נתונים

### mutate

בסיסי, חשבון
string - גזירת אותיות, צירוף אותיות
separate?


ifelse()
שינוי סוגי עמודות
recoding, cat

mutate

פעולות לפי קבוצות (ממוצעים, נרמול וכו')

##סיכום נתונים 

group_by()
summary()

first / last
min, max, mean, quantile

## צירוף נתונים

יצירת עמודות מתאימות
כיוון הצירוף (innerjoin)
בעיות בצירוף (שינוי סוג העמודות)



