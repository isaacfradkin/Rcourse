---
title: "Lesson 9: Loops and Efficiant Coding" 
author: "Copyright 2024 Psychology Department. Hebrew University of Jerusalem. All rights reserved"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false


description: >
 <div style='direction: rtl;'>
 בשיעור זה נלמד על מספר טכניקות לקידוד יעיל וניהול קבצי קוד.
 </div>
       
runtime: shiny_prerendered  
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
.text-block1 {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #e7f3fe; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ddd; /* Light border */
  margin: 10px 0; /* Space around the block */
}


.extra_functions {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #f0e6d3; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #9c8e73; /* Light border */
  margin: 10px 0; /* Space around the block */
}


</style>
```

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(Rcourse)
library(ggplot2)
library(tidyverse)

knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(warning = FALSE)

gradethis::gradethis_setup()


df = data.frame(subject = rep(c("Bruce","Jemima","Chanique","Marvin"),each = 10),
                score = rep(c(70,80,85,75),each = 10) + rnorm(40,0,5))

{
slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
intercepts = c(2, 3, 1, 2.5, 3.5)
names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

social_sleep  = data.frame()

for (i in 1:5){
  name = names[i]
  slope = slopes[i]
  intercept = intercepts[i]
  
  sleep = rnorm(30, 7, 1)
  social = slope*sleep + intercept + rnorm(30, 0, 1)
  
  temp_df = data.frame(name = name,
                       day = 1:30,
                       sleep = sleep,
                       social = social)
  social_sleep = bind_rows(social_sleep, temp_df)
}

social_sleep  = social_sleep  %>% mutate(sleep = round(sleep,1),
                                         social = round(social))
} # social sleep
```

```{r prepare-social_sleep}
set.seed = c(12345)
slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
intercepts = c(2, 3, 1, 2.5, 3.5)
names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

social_sleep  = data.frame()

for (i in 1:5){
  name = names[i]
  slope = slopes[i]
  intercept = intercepts[i]
  
  sleep = rnorm(30, 7, 1)
  social = slope*sleep + intercept + rnorm(30, 0, 1)
  
  temp_df = data.frame(name = name,
                       day = 1:30,
                       sleep = sleep,
                       social = social)
  social_sleep = bind_rows(social_sleep, temp_df)
}

social_sleep  = social_sleep  %>% mutate(sleep = round(sleep,1),
                                         social = round(social))
```

```{r prepare-func1}
mystery_function <- function(celsius) {
    fahrenheit <- (celsius * 9/5) + 32
    return(fahrenheit)
}
```

```{r prepare-func2}
mystery_function_2 <- function(x, value) {
    below <- sum(x < value)
    equal <- sum(x == value)
    n <- length(x)
    return((below + 0.5 * equal) / n * 100)
}
```

## מבוא

ביחידה זו נלמד על מספר טכניקות חשובות לקידוד תמציתי, מסודר ואפקטיבי.

בתחילת היחידה נלמד על לולאות ופונקציות, ובהמשכה על קידוד מסודר, ניהול
קבצי קוד ודרכים שונות לייצא נתונים ולהפיק דוחות.

## לולאות

עקרון מנחה חשוב בכתיבת קוד יעיל הוא הימנעות מחזרה על קוד מספר פעמים.

אם, למשל, אנחנו מעוניינים לעשות את אותה הבדיקה על ארבעה שאלונים שונים -
אנחנו נרצה להימנע מלכתוב את הקוד שמבצע את הבדיקה ארבע פעמים, כאשר ההבדל
היחיד בין החזרות הוא שם השאלון.

במקום זאת נוכל להשתמש בלולאה.

### הגדרת לולאה

לולאת קוד מוגדרת בצורה הבאה:

```{r loop_example,eval=FALSE}
for (object in vector){
  # Do stuff with each object
  
}
```

למשל:

```{r loop_example_2}
for (i in c("a","b","c")){
  print(i)
}
```

::: text-block1
הלולאה מורכבת משני חלקים:

**1. הגדרת הלולאה:** שורת הפתיחה של הלולאה (`for (i in c("a","b","c"))`)
מגדירה על אילו אובייקטים אנחנו רוצים שהלולאה תרוץ. במקרה שלנו מדובר
באיברים של הוקטור `c("a","b","c")`. הלולאה תרוץ על כל אחד מהאיברים, לפי
הסדר, ותייצג כל אחד מהם בתורו באמצעות `i`.

**2. הגדרת הלולאה עצמה:** חלק זה תחום בתוך הסוגריים המסולסלים `{}` שבאים
מיד אחרי הגדרת הלולאה וכולל את הקוד שיתבצע בכל סבב שלה.
:::

במקרה הנ"ל התוכנה תיקח את האיבר הראשון של הוקטור `c("a","b","c")`, תציב
אותו בתור `i` ותבצע את הקוד שנמצא בתוך הסוגריים המסולסלים - תדפיס את
ערכו ("a").

לאחר השלמת הסבב הראשון, התוכנה תחזור לתחילת הלולאה, תציב בתור `i` את
האיבר השני בוקטור - האות "b", ותבצע את הלולאה שוב. הפעם היא תדפיס "b".

בסבב השלישי התוכנה תציב ב`i` את האיבר השלישי בוקטור - "c", ותדפיס "c".

לאחר שסיימה לעבור על כל הערכים בוקטור, הלולאה תסתיים והתוכנה תעבור לבצע
את קטע הקוד הבא שביקשנו ממנה להריץ).

`תרגיל`

השלימו את הקוד בלולאה הבאה כך שידווח על הציונים של כל משתתף. בכל חזרה של
הלולאה אנחנו נרצה שהיא תיגש לשורה אחרת בטבלה שלנו (לפי מספר הסבב), תשלוף
את השם ואת הציון של הנבדק שאותה שורה מייצגת ותדפיס דיווח על הציון של
אותו הנבדק.

```{r loops_ex1, exercise=TRUE, exercise.eval = FALSE}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = __________
  
  # get score
  score = _________
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```

```{r loops_ex1-solution}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = data$name[i]
  
  # get score
  score = data$score[i]
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```

```{r loops_ex1-check}

grade_this({
  
printed_string = "[1] \"David Scored 80 points\"\n[1] \"Pnina Scored 90 points\"\n[1] \"Yossi Scored 70 points\"\n[1] \"Rina Scored 85 points\"\n"



  if (identical(.evaluate_result[[4]],
                printed_string)) {
    pass("מעולה")
  }
  fail("נסו שוב")
})

```

הלולאה תעבור על כל הערכים בוקטור `1:nrow(data)` (במקרה הזה, המספרים מ1
עד 4) ותשמור את הערך כ`i`. נשתמש בערך זה לשליפת השם והציון של הנבדק
בשורה המתאימה בכל סבב של הלולאה.

::: extra_functions
הפונקציות `paste` ו`paste0` משמשות כדי לחבר יחד מחרוזות (מילים, אותיות).
בדוגמה הקודמת הפונקציה משלבת את שם הנבדק והציון שלו לכדי משפט קוהרנטי.

ההבדל בין הפונקציות הוא בכך ש`paste` מוסיפה רווחים בין המחרוזות שהיא
מחברת ואילו `paste0` לא מוסיפה רווחים
:::

### דוגמא נוספת

בדרך כלל נרצה שהלולאות יעשו יותר מאשר רק לשלוף ולהדפיס ערכים. התבוננו
בלולאה הבאה ונסו להבין את מטרתה:

```{r loop_example_3,eval=FALSE}
Questionaires = c("anxiety","depression","stress")
 
for (q in Questionaires){
  fitlered_data = data %>% filter(Questionaire == q)               # filter data
  plot = ggplot(fitlered_data, aes(x = score)) + geom_histogram()  # create plot
   
  filename = paste0(q, ".png")                                     # create filename
  ggsave(filename, plot)                                           # save plot as image
}
 
```

```{r loops_q1, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("הלולאה מחשבת את הממוצע של ציוני המשתתפים בכל שאלון",
                message = "נסו שוב! שימו לב שהלולאה אינה מבצעת חישובים על הנתונים"),
         answer("הלולאה מייצרת תרשים המשווה בין הציון הממוצע בכל שאלון",
                message = "נסו שוב! שימו לב שהלולאה מייצרת תרשים נפרד בכל סבב"),
         answer("הלולאה מייצרת שלושה עותקים של אותו התרשים, המכיל את פיזור הציונים בשלושת השאלונים",
                message = "נסו שוב! שימו לב שבכל סבב של הלולאה התרשים שנוצר מתבסס על נתונים אחרים"),
         answer("הלולאה מייצרת תרשים נפרד עבור פיזור הציונים בכל שאלון ושומרת אותו כתמונה", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה. בכל סבב של הלולאה היא חותכת מתוך הטבלה את השורות הרלוונטיות לשאלון, מייצרת היסטוגרמה עבור ציוני שאלון זה, מייצרת את שם הקובץ על סמך שם השאלון ושומרת בשם זה את התרשים.", 
  incorrect = "נסו שוב"
)
```

שימו לב שאפשר להשתמש בכל שם שנרצה עבור האובייקט שמשתנה בכל סבב של
הלולאה. במקרה הנ"ל קראנו לו `q` והשתמשנו בו תחת שם זה לאורך הלולאה.

### שמירת תוצרי הלולאה

לעיתים קרובות נרצה לשמור את תוצרי הלולאה באובייקט כלשהו. נוכל לעשות זאת
באמצעות הגדרת אובייקט חדש שאליו נוסיף את הערכים שחישבנו בכל סבב של
הלולאה.

נמחיש באמצעות מספר דוגמאות:

הוספת התוצאה לסוף הוקטור באמצעות הפונקציה `c()`

```{r loops_save_example,  exercise=TRUE, exercise.eval = FALSE}
# וקטור ריק
results = c()

subjects = df$subject %>% unique() # וקטור המכיל את שמות / מספרי הנבדקים
                                   # כשכל שם מופיע רק פעם אחת
for (subj in subjects){
  subj_data = df %>% filter(subject == subj) # שליפת נתוני הנבדק
  subj_mean = subj_data %>%                  # חישוב הציון הממוצע
    pull(score) %>%
    mean() 
  
  results = c(results, subj_mean)  # הוספת ממוצע הנבדק לוקטור התוצאות
}

print(results)
```

הוספת תוצאות לוקטור באמצעות השמה לאינדקס ספציפי - `results[i]`.

```{r loops_save_example_2,  exercise=TRUE, exercise.eval = FALSE}
# וקטור ריק
results = c()

subjects = df$subject %>% unique() # וקטור המכיל את שמות / מספרי הנבדקים
                                   # כשכל שם מופיע רק פעם אחת
for (i in 1:length(subjects)){
  subj_data = df %>% filter(subject == subjects[i]) # שליפת נתוני הנבדק
  subj_mean = subj_data %>%                         # חישוב הציון הממוצע
    pull(score) %>%
    mean() 
  
  results[i] =  subj_mean  # הוספת ממוצע הנבדק לוקטור התוצאות
}

print(results)
```

הוספת התוצאות לטבלה באמצעות `bind_rows`

```{r loops_save_example_3,eval=FALSE}

data_file_names = c("data_1", "data_2", "data_3")

df = data.frame()   # טבלה ריקה

for (file_name in data_file_names){
  temp_df = read.csv(paste0("folder/",file_name,".csv"))
  temp_df = temp_df %>%
    mutate(source = file_name)  # הוספת עמודה המציינת את מקור הנתונים
  
  df = bind_rows(df, temp_df)   # הפונקציה תצרף לטבלה שורות חדשות בכל סבב
}
```

```{r loops_q2, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה בקטע הקוד האחרון?
</div>",
         
         answer(" לגיל הנבדק"),
         answer("הלולאה ייצרת טבלה עם ארבע עמודות, מפצלת ושומרת אותה בשלושה קבצים נפרדים"),
         answer("מייצרת שלושה טבלאות נפרדות, ושומרת אותן בהתאם לשם הקובץ ממנו יובאו"),
         answer("טוענת טבלאות משלושה קבצים ומאחדת אותן לטבלה אחת", correct = TRUE),
         allow_retry = TRUE,
         
  correct="תשובה נכונה", 
  incorrect = "נסו שוב"
)
```

### תרגיל בניית לולאה

הנתונים בטבלה `social_sleep` מתארים את שעות השינה וציוני החברתיות עבור 5
נבדקים בכל יום במשך חודש.

הצצה לשורות הראשונות בטבלה:

```{r, echo = F}
head(social_sleep, 4)
```

`תרגיל` צרו לולאה המחשבת עבור כל נבדק את המתאם בין שעות השינה והחברותיות
באותו היום.

היעזרו בפונקציה `cor` המחשבת את המתאם בין שני וקטורים של מספרים באופן
הבא:

```{r, eval = F}
r = cor(x = vector1, y = vector2)
# שני הוקטורים הם וקטורים מספריים באותו האורך
# והתוצה היא מספר בין -1 ל1
```

```{r loops_ex2, exercise=TRUE, exercise.eval = FALSE}

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# כתבו כאן את הלולאה
for (__________){
  
  # שליפת הנתונים של הנבדק
  
  # חישוב המתאם
  
  # הוספת הערך שחושב לוקטור
  # correlations
}



# יצירת תרשים על סמך התוצאות  - אין צורך לערוך את חלק זה
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+ # דרך נוספת לצייר עמודות
  ylab("Correlation")

```

```{r loops_ex2-solution}

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# בנו את הלולאה כאן

for (subj in subjects){
  subj_data = social_sleep %>% filter(name == subj)
  r = cor(subj_data$sleep, subj_data$social)
  correlations = c(correlations, r)
}


# יצירת תרשים על סמך התוצאות
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+
  ylab("Correlation")
```

```{r loops_ex2-check}

grade_this({
if (identical(user_object_get("correlations"),
              solution_object_get("correlations"))){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }
})

```

### לולאות בתוך לולאות

את התרגיל הקודם יכולנו לפתור גם באמצעות הכלים שלמדו בסמסטר בקודם -
באמצעות הפונקציות `group_by` ו `summarise`. לעומת זאת, לולאות מאפשרות
לנו גם לבצע ניתוחים נוספים, שאינם אפשריים (או אינם נוחים) בכלים שלמדנו
קודם.

למשל, אם נניח שהנבדקים בטבלה שלנו מכירים זה את זה יכול להיות שנרצה לבדוק
את המתאם בציוני החברותיות ביניהם - כדי לראות אם הם משפיעים זה על זה או
מושפעים מגורמים משותפים.

כדי לעשות זאת נצטרך להשוות בין כל צמד משתתפים ולבחון את המתאם בין
הציונים שלהם. נוכל לעשות זאת באמצעות לולאה שנמצאת בתוך לולאה אחרת:

הלולאה הראשונה תבחר נבדק אחד, והשנייה תערוך השוואה של נבדק זה אל מול כל
שאר הנבדקים (כולל עצמו) אחד אחד.

```{r nested_loops_example, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-social_sleep"}

print(head(social_sleep)) # הצצה אל תוך קובץ הנתונים


subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

df = data.frame(subj1 = c(), # טבלה ריקה 
                subj2 = c(),
                r = c())

for (subj1 in subjects){
  for (subj2 in subjects){
      print(paste(subj1,"vs",subj2))     # הדפסה שנועדה להמחיש את האופן שבו הלולאות עובדות
    
      subj1_social = social_sleep %>% filter(name == subj1) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק אחד
      subj2_social = social_sleep %>% filter(name == subj2) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק נוסף
      
      r = cor(subj1_social, subj2_social) # נחשב את המתאם בין דירוגי החברותיות
      
      new_row = data.frame(subj1 = subj1, # נסדר את שמות הנבדקים שביניהם חישבנו את המתאם
                           subj2 = subj2,
                           r = r)         # ואת מקדם המתאם שקיבלנו  בתור שורה בטבלה
      
      df = bind_rows(df, new_row)         # נצרף את השורה שיצרנו לטבלה הכללית
  }
}

print(head(df))   # נדפיס את השורות הראשונות של הטבלה שיצרנו

# הצגת המתאמים באמצעות תרשים חום
# ככל שהמתאם חזק יותר - צבע הרקע חזק יותר (בהתאם לכיוון המתאם)
ggplot(df %>% mutate(r = ifelse(r ==1, NA, r)), # נמיר את המתאם של כל נבדק עם עצמו לערך חסר,
       aes( x = subj1, y = subj2))+             #  כדי שלא יפיעו על סקאלת הצבעים
  geom_tile(aes(fill = r))+
  geom_text(aes(label = round(r,2)), color = "white")+
  scale_fill_gradient2(low = "red", high = "blue")+
  theme_minimal()

```

### שימוש בלולאות לטובת סימולציות

שימוש חשוב נוסף של לולאות מאפשר לנו לייצר הדמיה (או בלעז: סימולציה) של
תהליכים המכילים אקראיות. במקרים כאלו נרצה לחזור שוב ושוב על התהליך כדי
לגבש הבנה טובה יותר של התפלגות התוצאות שאנחנו יכולים לקבל.

למשל, נוכל לבצע סימולציה כדי לבדוק את התפלגות הערכים הצפויים עבור סכומם
של שתי הטלות קובייה.

```{r simulation_cube}
results = c()
n_iterations = 10000

for (i in 1:n_iterations){ # נחזור על התהליך 1000 פעם
  result1 = sample(x = 1:6, size = 1) # הטלה ראשונה: נדגום אקראית מספר מ1 עד 6
  result2 = sample(x = 1:6, size = 1) # הטלה שנייה: נדגום מספר נוסף
  sum_of_both = result1 + result2 # נחשב את סכום את 2 ההטלות
  
  results[i] = sum_of_both # נוסיף את הסכום שקיבלנו לוקטור
}

results_sum = data.frame(value = results) %>%   # נעביר את התוצאות לוקטור
  group_by(value) %>%                           # ונסכם את כמות ואחוז הפעמים שקיבלנו כל תוצאה
  summarise(n = n(),
            percent =n/n_iterations)


ggplot(results_sum, aes( x = value, y = percent))+  # נמחיש את התוצאות: הגדרת צירים
  geom_col()+                                       # הוספת עמודות
  scale_y_continuous()

print(head(results_sum))
```

ענו על השאלה הבאה על סמך תוצאות הסימולציה:

```{r loops_q3, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה הסיכוי (בקירוב) להטיל שתי קוביות שסכום תוצאות ההטלה שלהן הוא 3?
  </div>",
  answer("25%"),
  answer("15%"),
  answer("10%"),
  answer("5%", correct = TRUE),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

ביחידה הבאה נלמד בצורה מעמיקה יותר על סימולציות, השימושים השונים בהם
ואיך עורכים אותן.

## פונקציות

דרך נוספת בה אנחנו יכולים לעשות שימוש חוזר באותו הקוד כוללת הגדרה של
פונקציות.

מבחינה רעיונית, שיטה זו דומה מאוד לשימוש בלולאות - אבל במקום להריץ את
הקוד שבלולאה מספר פעמים ברצף אנחנו "אורזים" אותו לשימוש עתידי כך שנוכל
להשתמש בו בצורה נוחה מתי שיהיה לנו צורך בכך, במקום לכתוב מחדש את כל קטע
הקוד.

הגדרה של פונקציה תיראה כך:

```{r functions_example}
my_function = function(a,b){
  # do stuff
  c = a+b
  
  return (c)
}

#שימוש בפונקציה
result = my_function(1,2)

```

בניגוד ללולאות, פונקציות מכילות 2 חלקים נוספים:

**1) הגדרת הארגומנטים שהפונקציה מקבלת:** בדוגמה הנ"ל הפונקציה מצפה לקבל
מאיתנו 2 ערכים, אותם היא מכנה `a` ו`b`.

**2) הגדרת הערכים שהפונקציה מחזירה:** חלק זה יקבע את התוצר שנקבל כשנשתמש
בפונקציה בדוגמה הנ"ל הפונקציה מחזירה את הסכום של שני המספרים שהיא קיבלה
מאיתנו.

שימו לב: בניגוד ללולאות, אובייקטים שנייצר בתוך פונקציה לא יישמרו. התוצר
היחיד שנקבל מהפונקציה הוא הערך שהפונקציה מחזירה.

### דוגמא

לפניכם קוד המגדיר פונקציה. נסו להבין את מטרתה.

```{r functions_example_2}
mystery_function <- function(celsius) {
    fahrenheit <- (celsius * 9/5) + 32
    return(fahrenheit)
}
```

```{r guess_function_1,exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-func1" }

mystery_function( celsius = 200)

mystery_function( celsius = c(150, 175, 200, 225, 250))

```

```{r functions_q4, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה מטרתה של הפונקציה?
  </div>",
  answer("המרה של טמפרטורה ממעלות פרנהייט למעלות צלזיוס"),
  answer("המרה של טמפרטורה ממעלות צלזיוס למעלות פרנהייט", correct = TRUE),
  answer("המרת נתוני טמפרטורה מטבלה לוקטור"),
  answer("שמירת נתוני הטמפרטורה כטבלה"),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

### תרגיל כתיבת פונקציה

כתבו פונקציה המקבלת וקטור של מספרים ומחזירה אותו בתור ציוני תקן.

```{r func_exercise,exercise=TRUE, exercise.eval = FALSE }
Z_score_function = # כתבו את הפונקציה כאן
  # הפונקציה צריכה לקבל וקטור 
  # לחשב את הממוצע וסטיית התקן שלו
  # ואז לחשב את ציוני התקן
  # זכרו: ציוני תקן מחושבים כך: (ערך - ממוצע) / סטיית תקן
  
  # אל תשכחו להחזיר את וקטור ציוני התקן באמצעות
  # return
  # בסוף הפונקציה
  
  
  
# השאירו את שורת הקוד הבאה כפי שהיא
# השורה מיישמת את הפונקציה על וקטור ומדפיסה את התוכן שלו 
test_vector = 1:10
z_test_vector = Z_score_function(test_vector)
print(z_test_vector)
  
```

```{r func_exercise-solution}
Z_score_function = function(vec){
  z = (vec - mean(vec)) / sd(vec)
  
  return (z)
}
  
  
# השאירו את שורת הקוד הבאה כפי שהיא
# השורה מיישמת את הפונקציה על וקטור ומדפיסה את התוכן שלו 
test_vector = 1:10
z_test_vector = Z_score_function(test_vector)
print(z_test_vector)
```

```{r func_exercise-check}
grade_this({
if (identical(user_object_get("z_test_vector"),
                 solution_object_get("z_test_vector"))){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }
  
})
```

### דוגמה נוספת

התבוננו בדוגמה הבאה ונסו להבין את ייעודה של הפונקציה:

```{r functions_example_3}
mystery_function_2 <- function(x, value) {
    below <- sum(x < value)
    n <- length(x)
    return((below) / n * 100)
}

```

```{r guess_function_2,exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-func2" }

mystery_function_2( x = 1:10, value = 5)

```

```{r functions_q5, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה הפונקציה מבצעת?
  </div>",
  answer("חישוב הממוצע של וקטור"),
  answer("סינון ערכים הקטנים מערך נתון מתוך וקטור מספרי"),
  answer("חישוב אחוז הערכים הקטן מערך נתון בוקטור מספרי", correct = TRUE),
  answer("המרת וקטור עם נתוני שכיחות לאחוזים"),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

`תרגיל`

הקוד הבא אמור לייצר פונקציה שמקבלת וקטור מספרי ומחזירה וקטור מספרי
המוגבל לטווח מסויים.

כרגע, הקוד מדפיס ערך חסר.

זהו את הבעיה ותקנו אותה, כך שהקוד ימלא את הייעוד שלו.

```{r no_return, exercise=TRUE, exercise.eval = FALSE}
limit_range <- function(vec, limits){
  # הפונקציה מקבלת וקטור מספרי
  # ווקטור נוסף המכיל 2 ערכים המשווים את קצוות הטווח הרצוי
  # ומחזירה וקטור שבו הערכים שהיו מחוץ לטווח מוחלפים בערכים חסרים
  
    out_of_limits = vec < limits[1] | vec > limits[2]
    vec[out_of_limits] = NA
}

test_vector = 1:10
test_limits = c(3,7)
print(limit_range(vec = test_vector, limits = test_limits))

```

```{r no_return-hint-1}
האם הפונקציה מחזירה ערך כלשהו?
```

```{r no_return-hint-2}
כדי להחזיר ערך, הפונקציה צריכה לכלול את הפקודה 
return(object_to_be_returned)
```

```{r no_return-check}
grade_this({
  
  vec = 2:30
  limits = c(10,20)
  
  f = user_object_get("limit_range")
  test = f(vec, limits)
  
  out_of_limits = vec < limits[1] | vec > limits[2]
  vec[out_of_limits] = NA
  
if (identical(test, vec)){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }
  
})

```

## ניהול קבצי קוד

### הערות וקיפולי קוד

כמה כלים פשוטים לניהול קוד ברור ומסודר:

**1) הערות:** ההמלצה הנפוצה היא להוסיף כמה שיותר הערות - כדי להסביר את
המטרה של כל שורת קוד וכל מקטע. זה אמנם ידרוש מכם עוד כמה שניות בזמן
הכתיבה אבל זה מאוד עוזר בהתמצאות בקוד אח"כ, ומייסע לסדר לעצמכם את מהלך
הניתוח.

**2) חלוקה לפרקים:** כלי שימושי נוסף כולל חלוקה של קובץ הקוד לפרקים, לפי
חלקי הניתוח השונים. ניתן לייצר כותרות לפרקים באמצעות הוספת ארבעה `#`
בסופה של הערה ולהסתיר את התוכן של הפרק על ידי לחיצה משמאל לכותרת
בRstudio. בנוסף נוכל לנווט בין הכותרות השונות באמצעות כפתור שמופיע בצד
השמאלי של תחתית חלון הקוד או באמצעות חלונית הניווט, אותה ניתן לפתוח
באמצעות כפתור ה"Outline" שבפינה הימנית העליונה של המסך.

**3) קיפולי קוד:** דרך נוספת לצמצם קטעי קוד נעזרת בסוגריים מסולסלים -
`{}`. אם נקיף קטע קוד בסוגריים אלו נוכל לצמצם את קטע הקוד גם מבלי להגדיר
כותרות ופרקים חדשים. מומלץ להוסיף הערה אחרי הסוגר השני ולפרט בה מה הקוד
המקופל עושה, כדי שנוכל לעקוב אחרי מטרת הקוד מבלי לבטל את הצמצום.

כדי שהקוד שלכם יהיה מסודר ונח לקריאה, עריכה ושימוש מומלץ להשתמש בשלושת
הטכניקות.

תעתיקו את הקוד לRstudio ונסו בעצמכם (קיפולי קוד לא עובדים בלומדה).

```{r comments_example, eval = F}
# קובץ זה נועד כדי להדגים שימוש בהערות, ראשי פרקים וקיפולי קוד
#לחצו על החץ הקטן ליד מספר השורה כדי להסתיר את קטע הקוד הרלוונטי


#  יצירת נתוני דמה וטעינת חבילות #### 

{
  library(dplyr)
  library(ggplot2)
} # טעינת החבילות
{
  
  # נתונים עבור יצירת הנתונים
  slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
  intercepts = c(2, 3, 1, 2.5, 3.5)
  # שמות הנבדקים
  names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")
  
  social_sleep  = data.frame() # טבלה ריקה
  
  for (i in 1:5){   # לולאה שעוברת על כל נבדק ומייצרת עבורו נתוני דמה
    # שליפת הפרמטרים עבור הנבדק
    name = names[i]
    slope = slopes[i]
    intercept = intercepts[i]
    
    sleep = rnorm(30, 7, 1)                           # דגימה אקראית של שעות השינה
    social = slope*sleep + intercept + rnorm(30, 0, 1)# חישוב מידת החברתיות על סמך שעות השינה
    
    temp_df = data.frame(name = name,             # ארגון נתוני הנבדק בטבלה
                         day = 1:30,
                         sleep = round(sleep,1),
                         social = round(social))
    
    social_sleep = bind_rows(social_sleep, temp_df)# הוספת נתוני הנבדק לטבלת הנתונים
  }

} # יצירת טבלת הנתונים באמצעות לולאה

# פרק 2 - סיכום הנתונים ####

{
  social_sleep_summ = social_sleep %>%  # חישוב ממוצע חברותיות ושעות שינה לכל נבדק
    group_by(name) %>%
    summarise(mean_sleep = mean(sleep),
              mean_social = mean(social))
} # סיכום בסיסי לפי נבדק
{
  social_sleep_summ = social_sleep_summ %>%
    group_by()%>% # ביטול של החלוקה לפי נבדק
    mutate(z_sleep = (mean_sleep - mean(mean_sleep))/ sd(mean_sleep), # חישוב ציוני התקן
           z_social = (mean_social - mean(mean_social))/ sd(mean_social))
  
} # חישוב ציון התקן של הממוצעים

# פרק 3 - יצירת תרשים ####

{
  ggplot(social_sleep_summ, aes( x = z_sleep, y = z_social))+
    geom_point(aes(col = name))+ # הוספת נקודה לכל נבדק
    geom_text(aes(label = name, y = z_social + 0.2))+ # הוספת שם הנבדק מעל הנקודה
    theme_minimal()+
    theme(legend.position = "none") # הסרת המקרא
} # תרשים ראשון - פיזור ציוני התקן של הממוצעים

{
  ggplot(social_sleep, aes( x = sleep, y = social, col = day))+
    geom_point(alpha = 0.5)+
    geom_smooth(method = "lm")+
    facet_wrap(~name)
} # תרשים שני - פיזור התצפיות לכל נבדק
```

### שימוש במספר קבצי קוד נפרדים

אמצעי שימושי נוסף כולל חלוקה של הקוד למספר קבצים.

בדרך כלל נייחד קובץ נפרד לכל חלק של הניתוח:

**1) הגדרת פונקציות**: קובץ שבו נגדיר את כל הפונקציות בהן נעשה שימוש
במהלך הניתוח

**2) טעינת הנתונים וסידורם:** טעינת טבלאות הנתונים הגולמיות, חישוב
משתנים חשובים וסינון של תצפיות בעייתיות

**3) הניתוח עצמו**: ביצוע מבחנים סטטיסטיים ויצירת תרשימים

שיטה זו תאפשר לנו לעבוד על קובץ נפרד כל פעם, מבלי שנצטרך לכתוב או להריץ
מחדש את הקבצים הקודמים בכל פעם.

#### אבל איך נעביר את המידע בין הקבצים?

במקום להריץ באופן ידני כל קובץ נוכל לשמור את הטבלאות, האובייקטים
והפונקציות שיצרנו בקובץ קוד אחד ולייבא אותם בקלות לקובץ הבא.

**1) טעינת קובץ קוד:** נשתנש בפקודה `source` כדי לקרוא לקובץ קוד אחד
מתוך קובץ אחר. השימוש הנפוץ ביותר בפקוה זו הוא כדי להריץ קובץ המכיל רק
הגדרה של פונקציות, ובכך לייבא את הפונקציות לסביבת העבודה שלנו. לדוגמה:
`source(name_of_file.R")`.

**2) שמירת קבצי CSV:** את שיטה זו למדנו בסמסטר קודם, והיא כוללת לייצא את
טבלאות הנתונים שעברו סינון ועיבוד ו/או את טבלאות הסיכום כקבצי CSV -
באמצעות הפקודה`write_csv`, שאותם נוכל לטעון בתחילת קובץ הקוד הבא.

**3) שמירת אובייקטים:** אם נרצה לייצא אובייקט שאינו בהכרח טבלה - נוכל
לייצא אותו כקובץ RDS. פורמט זה מיועד לשמירה וטעינה של אובייקטים בR
ומאפשר לנו לשמור ולטעון כל אובייקט שנרצה. שמירה נעשית באמצעות הפקודה
\``saveRDS(object, "name_of_file.rds")` וייבוא באמצעות
`readRDS("name_of_file.rds")`. פקודות אלו מתאימות לכל אובייקט בR, מכל
סוג שהוא. הוא נשמר בפורמט ייעודי של R ומיובא בצורה זהה לאובייקט המקורי.

#### ניקוי סביבת העבודה ושמירת אובייקטים

כדי לשמור על סביבת העבודה שלנו נקייה נוכל להשתמש בפקודה
`rm(list = ls())`. פקודה זו תמחק את כל האובייקטים שנמצאים בסביבת העבודה
שלנו, ותשאיר אותה ריקה ונקייה.

לחלופין, ניתן לבצע את הפעולה הזו ידנית באמצעות כפתור המטאטא שבסרגל הכלים
שבראש חלונית שסביבת העבודה (Environment).

נכלול את שורת קוד זו בתחילת קבצי הR שלנו כדי לשמור על סביבת העבודה שלנו
נקייה ומסודרת.

## ייצוא תוצאות

השלב האחרון בתהליך עיבוד הנתונים כולל את ייצוא התוצאות. לאחר שהפקנו את
התרשימים, ייצרנו את טבלאות הסיכום וביצענו את המבחנים הסטטיסטיים - נרצה
לייצא אותם לטובת דיווח או שיתוף.

אפשר לייצא את התוצאות באופן ידני - יל ידי הרצת הקבצים והעתקת התוצאות
והתרשימים לקובץ חיצוני כלשהו אחד אחד, אבל נוכל לעשות זאת גם בצורה נוחה
יותר:

**1) באמצעות פקודות המייצאות את התוצאות:**

את הטבלאות נוכל לשמור כקבצי CSV באמצעות הפקודה `write.csv`

את התרשימים נוכל לשמור באמצעות פונקציות כמו `ggsave` המייצאות את
התרשימים כקובץ תמונה

ואת הניתוחים הסטטיסטיים נוכל לייצא כטבלאות דיווח באמצעות מערך של
פונקציות המסדרות את התוצאות בטבלאות ושומרות אותן כקבצי וורד. קישור
לדוגמא. <https://rempsyc.remi-theriault.com/articles/t-test>

**2) באמצעות Rmarkdown:**

Rmarkdown הוא כלי המאפשר לנו לייצר מסמכים ודוחות ישירות מתוך R. הוא מכיל
קטעי קוד שמשובצים בתוך מסמך טקטס, ומאפשר לנו להציג את הקוד, הפלטים
והתרשימים שאנחנו מייצרים באופן מסודר ובליווי הסברים מילוליים.

כדי לייצר קובץ Rmarkdown נלחץ על כפתור יציר ת קובץ חדש שבפינה השמאלית
עליונה של Rstudio ונבחר באופציה של מסמף Rmarkdown.

כשנסיים לייצר את הקובץ נוכל להפיק אותו באמצעות פעולה הנקראת "Knit",
ולקבל קובץ חדש המכיל את הטקסט והתוצאות שלנו. בצורה זו ניתן לייצר קבצי
וורד, PDF או קבצי html המכילים את התוצאות שלנו. בפורמט html נוכל אפילו
לכלול טבלאות ותרשימים אינטראקטיביים.

בתרגיל המסכם תפגשו דוגמה לקובץ שכזה, המדגים שימוש בכלים שנלמדו ביחידה
זו.

למידע נוסף על Rmarkdown ואופן השימוש בו תוכלו להשתמש במדריכים אינטרנטיים
רבים שקיימים ברשת. לדוגמה:

[מדריך מסודר המלווה במספר דוגמאות](https://rmarkdown.rstudio.com/)

[קובץ PDF המסכם את הכלים הבסיסיים ליצירת קבצים
בRmarkdown](https://rmarkdown.rstudio.com/lesson-15.HTML)

[מדריך מקיף על השימוש בRmarkdown](https://bookdown.org/yihui/rmarkdown/)

[מדריך מקיף נוסף](https://r4ds.had.co.nz/r-markdown.html)

## תרגיל

![](images/Rstudio%20logo.png){width="100"}

כדי לתרגל את הנושאים שנלמדו ביחידה זו נבצע ניתוח הכולל שימוש בלולאות קוד
ופונקציות. ניתוח זה לא יהיה מורכב מדי, אך כדי לתרגל ניהול ניתוחים
מורכבים יותר נבצע אותו באמצעות מספר קבצים נפרדים, כפי שלמדנו ביחידה.

הורידו מהמודל את שלושת קבצי הקוד ואת שלושת קבצי הנתונים שבתיקיית "יחידה
9". ושמרו אותם בתיקיית העבודה שלכם.

הוראות לתרגיל לפי קבצים:

-   "9_functions":

    -   צרו פונקציה המקבלת וקטור ומחזירה וקטור באותו האורך בו הערכים הקיצוניים (בעלי ציון תקן הגדול מ 2.5) הוחלפו בערכים חסרים

    -   וודאו שהיא עובדת בצורה תקינה ושמרו את הקובץ המעודכן

-   "9_main_analysis":

    -   ייבאו את קובץ הפונקציות באמצעות הפקודה `source`

    -   צרו לולאה המייבאת ומאחדת את את שלושת קבצי הנתונים. הקבצים כולם
        בעלי מבנה זהה, כך שניתן לחבר אותם זה לזה על ידי הפקודה
        `bind_rows`.

    -   היעזרו בפונקציה שייבאתם כדי להוסיף לטבלה עמודה המכילה את ציוני הנבדקים כאשר הערכים הקיצוניים הוחלפו בערכים חסרים
    
    -   צרו טבלה המסכמת את הציון הממוצע עבור כל נבדק

    -   שמרו את טבלת הסיכום כקובץ RDS

-   "9_report_results":

    -   ייבאו את קובץ הRDS שייצרתם באמצעות הפקודה `readRDS`

    -   הפיקו את הקובץ באמצעות כפתור ה"Knit"

    -   בדקו את הקובץ שנוצר (הוא יימצא בתיקיית העבודה שלכם) והעלו אותו, יחד
        עם שלושת קבצי הקוד לתיבת ההגשה של יחידה זו.

בהצלחה!

## הגשה

עברו על הקובץ וודאו שהגשתם את כל התרגילים ועניתם על כל השאלות

במידה וכל התשובות שלכם תקינות יש ללחוץ על הכפתור: Generate, להעתיק את
הטקסט שמופיע בחלון למטה ולהגישו במודל\
בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```
