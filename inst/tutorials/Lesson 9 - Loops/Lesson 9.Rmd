---
title: "Lesson 9: Loops and Clean coding" 
author: "Copyright 2024 Psychology Department. Hebrew University of Jerusalem. All rights reserved"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false


description: >
 <div style='direction: rtl;'>
 
 </div>
       
runtime: shiny_prerendered  
editor_options: 
  markdown: 
    wrap: 72
---


```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
.text-block1 {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #e7f3fe; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ddd; /* Light border */
  margin: 10px 0; /* Space around the block */
}
</style>

```

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(Rcourse)
library(ggplot2)
library(tidyverse)

knitr::opts_chunk$set(error = TRUE)
gradethis::gradethis_setup()
```

```{r prepare-social_sleep}

slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
intercepts = c(2, 3, 1, 2.5, 3.5)
names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

social_sleep  = data.frame()

for (i in 1:5){
  name = names[i]
  slope = slopes[i]
  intercept = intercepts[i]
  
  sleep = rnorm(30, 7, 1)
  social = slope*sleep + intercept + rnorm(30, 0, 1)
  
  temp_df = data.frame(name = name, sleep = sleep, social = social)
  social_sleep = bind_rows(social_sleep, temp_df)
}

social_sleep  = social_sleep  %>% mutate(sleep = round(sleep,1),
                                         social = round(social))
```

## מבוא

ביחידה זו נלמד על מספר טכניקות חשובות לקידוד מסודר ואפקטיבי. במהלך היחידה נלמד על לולאות ופונקציות וכיצד להשתמש בהן כדי לכתוב קוד יעיל ותמציתי, נעבור על מספר המלצות לניהול קבצי קוד מורכבים ונגע במספר פרקטיקות המסייעות בניהול של ניתוחים ארוכים ותוצאותיהן.


הצורך בשמירה על הקוד תמציתי הוא כפול - כתיבה כזו היא גם יעילה ומהירה יותר לכתיבה ומאפשרת לנו לבצע בקוד תיקונים ושינויים בצורה נוחה, והיא גם חשובה כדי שיהיה לנו קל יותר להבין את הקוד שכתבנו כשנחזור אליו במועד עתידי. ייתכן שלחלקכם נושאים אלו נשמעים כשוליים בחשיבותם לקידוד עצמו, אבל כבר בפרוייקט הקידוד הראשון שלכם אתם צפויים לגלות שהם חיוניים עבור כל ניתוח שתבצעו. 

היחידה מכילה מספר נושאים:

 לולאות קוד
 
 פונקציות
 
 הערות, חלוקה לפרקים וכיפולי קוד
 
 שמירה וייצוא תוצאות
 
 יצירת מסמכים בRmarkdown


## לולאות

אחד העקרונות המנחים החשובים ביותר בכתיבה של קוד יעיל הוא הימנעות מחזרה על אותו הקוד מספר פעמים. 
  
  
אם, למשל, אנחנו מעוניינים לעשות את אותה הבדיקה על ארבעה שאלונים שונים - אנחנו נרצה להימנע מלכתוב את הקוד שמבצע את הבדיקה ארבע פעמים, כשההבדל היחיד בין החזרות הוא בשם השאלון.

במקום זאת נוכל להשתמש בלולאת קוד.


### הגדרת לולאה

לולאת קוד מוגדרת בצורה הבאה:

```{r,eval=FALSE}
for (object in vector){
  # Do stuff with each object
  
}
```

למשל:

```{r}
for (i in c("a","b","c")){
  # Do stuff with each object
  print(i)
}
```

אפשר להבחין בשני חלקים נפרדים בקוד:

  **1. הגדרת האובייקטים שישתתפו בלולאה:** השורה שפותחת את הלולאה (`for (i in c("a","b","c"))`) מגדירה על אילו אובייקטים אנחנו רוצים שהלולאה תרוץ. במקרה שלנו מדובר באיברים של הוקטור `c("a","b","c")`. הלולאה תרוץ על כל אחד מהאיברים, לפי הסדר, ותייצג אותם בתור `i`.

  **2. הגדרת הלולאה עצמה:** חלק זה תחום בתוך הסוגריים המסולסלים `{}` שבאים מיד אחרי הגדרת האובייקטים של הלולאה וכולל את הקוד שיתבצע בכל סבב שלה.

  
במקרה הנ"ל התוכנה תיקח את האיבר הראשון של הוקטור `c("a","b","c")`, תציב אותו בתור `i` ותבצע את הקוד שנמצא בתוך הסוגריים המסולסלים - תדפיס את ערכו ("a").
  
אחרי שסיימה לבצע את הסבב הראשון של הלולאה התוכנה תחזור לתחילת הלולאה, תציב בתור `i` את האיבר השני בוקטור - האות "b", ותבצע את הלולאה שוב. הפעם היא תדפיס "b".

בסבב השלישי התוכנה תציב ב`i` את האיבר השלישי בוקטור - "c", ותדפיס "c".



`תרגיל`
השלימו את הקוד בלולאה הבאה כך שידווח על הציונים של כל משתתף. בכל חזרה של הלולאה אנחנו נרצה שהיא תיגש לשורה אחרת בטבלה שלנו (לפי מספר הסבב), תשלוף את השם ואת הציון של הנבדק שאותה שורה מייצגת ותדפיס דיווח על הציון של אותו הנבדק.



```{r loops_ex1 ,exercise=TRUE, exercise.eval = FALSE}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = __________
  
  # get score
  score = _________
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```


הלולאה תעבור על כל הערכים בוקטור `1:nrow(data)` (במקרה הזה, המספרים מ1 עד 4) ותשמור את הערך כ`i`.
נשתמש בערך זה כדי לשלוף את השם ואת הציון של הנבדק בשורה המתאימה בכל סבב של הלולאה.



### דוגמא נוספת

 בדרך כלל נרצה שהלולאות יעשו יותר מאשר רק לשלוף ולהדפיס ערכים. התבוננו בלולאה הבאה ונסו להבין את מטרתה:
 
 
```{r ,eval=FALSE}
Questionaires = c("anxiety","depression","stress")
 
for (q in Questionaires){
  fitlered_data = data %>% filter(Questionaire == q)               # filter data
  plot = ggplot(fitlered_data, aes(x = score)) + geom_histogram()  # create plot
   
  filename = paste0(q, ".png")                                     # create filename
  ggsave(filename, plot)                                           # save plot as image
}
 
```

לולאה זו מדגימה שאפשר להשתמש בכל שם שנרצה עבור האיבר שמשתנה בכל סבב של הלולאה. במקרה הנ"ל קראנו לו `q` והשתמשנו בו תחת שם זה לאורך הלולאה.


```{r loops_q1, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("הלולאה מחשבת את הממוצע של ציוני המשתתפים בכל שאלון",
                message = "נסו שוב. שימו לב שהלולאה אינה מבצעת אף חישוב על הנתונים"),
         answer("הלולאה מייצרת תרשים המשווה בין הציון הממוצע בכל שאלון",
                message = "נסו שוב. שימו לב שהלולאה מייצרת תרשים נפרד בכל סבב"),
         answer("הלולאה מייצרת שלושה עותקים של אותו התרשים, המכיל את פיזור הציונים בשלושת השאלונים",
                message = "נסו שוב. שימו לב שבכל סבב של הלולאה התרשים שנוצר מתבסס על נתונים אחרים"),
         answer("הלולאה מייצרת תרשים נפרד עבור פיזור הציונים בכל שאלון ושומרת אותו כתמונה", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה. בכל סבב של הלולאה היא חותכת מתוך הטבלה את השורות הרלוונטיות לשאלון, מייצרת היסטוגרמה עבור ציוני שאלון זה, מייצרת את שם הקובץ על סמך שם השאלון ושומרת בשם זה את התרשים.", 
  incorrect = "נסו שוב"
)
```

### שמירת תוצרי הלולאה


לעיתים קרובות נרצה לשמור את תוצרי הלולאה באובייקט כלשהו. נוכל לעשות זאת באמצעות הגדרת אובייקט חדש והשמה של הערך של האיבר בתוך הלולאה לאובייקט זה. ישנן שתי דרכים עיקריות כדי לבצע פעולה שכזו:

1) לייצר אובייקט ריק (למשל - וקטור או טבלה ריקה) ולהוסיף אליו איברים בכל סבב של הלולאה
2) לייצר אובייקט המלא בערכים חסרים ולהחליף את ערכים אלו בכל סבב של הלולאה

דוגמאות:

שמירת תוצאות לוקטור ריק
```{r}
# וקטור ריק
results = c()

subjects = df$subject %>% unique() # וקטור המכיל את מספרי הנבדקים, ללא חזרות

for (subj in subjects){
  subj_data = df %>% filter(subject == subj)
  
}

```


שמירת תוצאות לוקטור המכיל ערכים חסרים:


`שאלה`
התבוננו בקוד הבא ונסו להבין מה הוא מבצע: 

```{r ,eval=FALSE}

data_file_names = c("data_1", "data_2", "data_3")

df = data.frame(id = c(), 
                score = c(),
                age = c(),
                source = c())

for (file_name in data_file_names){
  temp_df = read.csv(paste0("folder/",file_name,".csv"))
  temp_df = temp_df %>%
    mutate(source = file_name)
  
  df = bind_rows(df, temp_df)
}
 
```


```{r loops_q2, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("מחשבת את הציון הממוצע של כל נבדק בקובץ ואת המתאם בין הציון הממוצע לגיל הנבדק",
                message = "נסו שוב. "),
         answer("מייצרת טבלה עם ארבע עמודות, מפצלת אותה ושומרת אותה כשלושה קבצים נפרדים",
                message = "נסו שוב."),
         answer("מייצרת שלושה טבלאות נפרדות, ושומרת אותן בהתאם לשם הקובץ ממנו יובאו",
                message = "נסו שוב."),
         answer("טוענת טבלאות משלושה קבצים ומאגדת אותן יחד לטבלה אחת", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה", 

)
```


### תרגיל בניית לולאה

הנתונים בטבלה `social_sleep` מתארים את שעות השינה וציוני החברתיות עבור 5 נבדקים בכל יום במשך חודש.

`תרגיל`
צרו לולאה המחשבת עבור כל נבדק את המתאם בין שעות השינה והחברותיות באותו היום. היעזרו בפונקציה `cor` המחשבת את המתאם בין שני וקטורים של מספרים.

```{r loops_ex2 ,exercise=TRUE, exercise.eval = FALSE, exercise.setup = prepare-social_sleep} 

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# בנו את הלולאה כאן




# יצירת תרשים על סמך התוצאות
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+
  ylab("Correlation")

```

```{r loops_ex2-solution}

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# בנו את הלולאה כאן

for (subj in subjects){
  subj_data = social_sleep %>% filter(name == subj)
  r = cor(subj_data$sleep, subj_data$social)
  correlations = c(correlations, r)
}


# יצירת תרשים על סמך התוצאות
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+
  ylab("Correlation")
```

```{r loops_ex2-check}
if (identical(user_object_get("correlations"),
                 solution_object_get("correlations"))){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }

```


### לולאות בתוך לולאות

את התרגיל הבא יכולנו לפתור גם באמצעות הכלים שלמדו בסמסטר בקודם - באמצעות הפונקציות `group_by` ו `summarise`. לעומת זאת, לולאות מאפשרות לנו גם לבצע ניתוחים נוספים, שאינם אפשריים (או אינם נוחים) בכלים שלמדנו קודם.

למשל, יתכן ונרצה להשוות בין כל צמד משתתפים ולבחון את המתאם בין הציונים שלהם. נוכל לעשות זאת באמצעות לולאה שנמצאת בתוך לולאה אחרת:

הלולאה הראשונה תעבור על שמות הנבדקים, ותערוך השוואה של הנבדק אלו מול כל שאר הנבדקים (כולל עצמו) באמצעות לולאה נוספת.

```{r, loops_ex3 ,exercise=TRUE, exercise.eval = FALSE, exercise.setup = prepare-social_sleep} 

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

df = data.frame(subj1 = c(), # טבלה ריקה 
                subj2 = c(),
                r = c())

for (subj1 in subjects){
  for (subj2 in subjects){
      subj1_social = social_sleep %>% filter(name == subj1) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק אחד
      subj2_social = social_sleep %>% filter(name == subj2) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק נוסף
      
      r = cor(subj1_social, subj2_social) # נחשב את המתאם בין דירוגי החברותיות
      
      new_row = data.frame(subj1 = subj1, # נסדר את שמות הנבדקים שביניהם חישבנו את המתאם
                           subj2 = subj2,
                           r = r)         # ואת מקדם המתאם שקיבלנו  בתור שורה בטבלה
      
      df = bind_rows(df, new_row)         # נצרף את השורה שיצרנו לטבלה הכללית
  }
}


ggplot(df, aes( x = subj1, y = subj2))+
  geom_tile(aes(fill = r))+
  geom_text(aes(label = round(r,2)), color = "white")+
  scale_fill_gradient2(low = "red", high = "blue")+
  theme_minimal()

```


`תרגיל`
*




### שימוש בלולאות לטובת סימולציות

שימוש חשוב נוסף של לולאות מאפשר לנו לייצר הדמיה של תהליכים המכילים אקראיות. במקרים כאלו נרצה לחזור שוב ושוב על התהליך כדי לגבש הבהנה טובה יותר של התפלגות התוצאות שאנחנו צפויים לקבל. 

למשל, נוכל לבצע סימולציה כדי לבדוק את התפלגות הערכים הצפויים עבור סכומם של שתי הטלות קובייה. 

```{r}
results = c()

for (i in 1:1000){ # נחזור על התהליך 1000 פעם
  result1 = sample(1:6) # הטלה ראשונה: נדגום אקראית מספר מ1 עד 6
  result2 = sample(1:6) # הטלה שנייה: נדגום מספר נוסף
  sum_of_both = result1 + result2 # נחשב את סכום את 2 ההטלות
  
  results = c(results, sum_of_both) # נוסיף את הסכום שקיבלנו לוקטור
}


ggplot(data.frame(results= results), aes( x = results))+
  geom_histogram()

```


* שאלה על ההתפלגות

ביחידה הבאה נלמד על שימושים נוספים של סימולציות


## פונקציות

דרך נוספת בה אנחנו יכולים לעשות שימוש חוזר באותו הקוד כוללת הגדרה של פונקציות.

מבחינה רעיונית, שיטה זו דומה מאוד לשימוש בלולאות - אבל במקום להריץ את הקוד שבלולאה מספר פעמים ברצף אנחנו "אורזים" אותו לשימוש עתידי כך שנוכל להשתמש בו בצורה נוחה מתי שיהיה לנו צורך בכך, במקום לכתוב מחדש את כל קטע הקוד.

הגדרה של פונקציה תיראה כך:

```{r}
my_function = function(a,b){
  # do stuff
  c = a+b
  
  return (c)
}

#שימוש בפונקציה
result = my_function(1,2)

```

בניגוד ללואלות, פונקציות מכילות 2 חלקים נוספים:

1) הגדרת הארגומנטים שהפונקציה מקבלת: בדוגמה הנ"ל הפונקציה מצפה לקבל מאיתנו 2 ערכים, אותם היא מכנה `a` ו`b`. 
2) הגדרת הערכים שהפונקציה מחזירה: חלק זה יקבע את התוצר שנקבל כשנשתמש בפונקציהץ בדוגמה הנ"ל הפונקציה מחזירה את הסכום של שני המספרים שהיא קיבלה מאיתנו.

שימו לב: בניגוד ללולאות, אובייקטים שנייצר בתוך פונקציה לא יישמרו. התוצר היחיד שנקבל מהפונקציה הוא הערך שהפונקציה מחזירה.


### דוגמא

לפניכם קוד המגדיר פונקציה. נסו להבין את מטרתה.

```{r}
mystery_function = function(df,column_name){
  column = df %>% pull(column_name)
  report = data.frame( mean = mean(column, sd = sd(column)))
  
  return (report)
}
```
* print df
* use function

* Q

`תרגיל`

### הדגמה נוספת

* פונקציה בלי החזרה

* תרגיל פשוט

* הדגמה מורכבת יותר

* תרגיל מורכב יותר


## ניהול קבצי קוד 

חשיבות שמירת קוד מסודר ומובנה + הערות

### חלוקה לפרקים וקיפולי קוד

### שימוש במספר קבצי קוד נפרדים

* הגדרת פונקציות בקובץ נפרד
* ניתוח ראשוני - שמירת קבצים - ניתוח משני - תרשימים

#### ניקוי סביבת העבודה ושמירת אובייקטים

## ייצוא תוצאות

* אפשר להריץ מחדש את הקובץ, לייצר את התרשימים, להדפיס את הערכים ולשמור אותם
* אפשר גם לייצא את התרשימים והערכים כקבצים חיצוניים
* ניתן להשתמש בפונקציות כמו `ggsave` ו- `write.csv` כדי לשמור את התוצאות

### Rmarkdown

דרך נוספת, המאפשרת לייצר קבצים ישירות מתוך R. מאפשרת עיבוד בסיסי (למרות סמומלץ לעשות את רוב העיבוד מראש) והדפסה של תוצאות ותרשימים - וייצאו באופן מסודר. 

הפנייה למקורות מידע נוספים ללימוד עצמאי


## תרגיל

* הפנייה לRstudio

הורידו מהמודל את שלושת תבניות קבצי הקוד ואת שלושת קבצי הCSV שבתיקיית "יחידה 9" ומקמו אותם בתיקיית העבודה שלכם. ניתן לברר מה היא תיקיית העבודה באמצעות הפונקציה `getwd()` או לשנות את תיקיית העבודה באמצעות `setwd("כתובת התיקייה החדשה")`.

1. פתחו את הקובץ "*", צרו בו פונקציה בשם X המקבלת. שמרו את הקובץ וסגרו אותו

2. פתחו את הקובץ "*" הריצו את שורת הקוד המנקה את סביבת העבודה (`rm(list = ls())`) וטענו את הפונקציה שיצרתם בסעיף הקודם באמצעות הפקודה `source`. עכשיו תוכלו להשתמש בפונקציה שיצרתם בקובץ הקוד החדש.

3. בקובץ קוד זה, יבאו את שלושת הקבצים ושלבו אותם יחד לטבלה אחת **באמצעות לולאה**. שימו לב להוסיף לכל טבלה עמודה המפרטת על המקור שלה לפני שהיא מצורפת לטבלאות האחרות.

4.שמירת קובץ R?

5. פתחו את קובץ הRMD



## הגשה
  עברו על הקובץ וודאו שהגשתם את כל התרגילים ועניתם על כל השאלות
  
  במידה וכל התשובות שלכם תקינות יש ללחוץ על הכפתור:  Generate, להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```