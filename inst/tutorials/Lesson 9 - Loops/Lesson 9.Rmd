---
title: "Lesson 9: Loops and Clean coding" 
author: "Copyright 2024 Psychology Department. Hebrew University of Jerusalem. All rights reserved"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false


description: >
 <div style='direction: rtl;'>
 
 </div>
       
runtime: shiny_prerendered  
editor_options: 
  markdown: 
    wrap: 72
---


```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
.text-block1 {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #e7f3fe; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ddd; /* Light border */
  margin: 10px 0; /* Space around the block */
}
</style>

```

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(Rcourse)
library(ggplot2)
library(tidyverse)

tutorial_options(
  exercise.timelimit = 60
)

knitr::opts_chunk$set(error = TRUE)
gradethis::gradethis_setup()
```

```{r prepare-df1}

```

## מבוא

ביחידה זו נלמד על מספר טכניקות חשובות לקידוד מסודר ואפקטיבי. במהלך היחידה נעבור 
ונקבל כלים חשובים לכתיבת קוד נקי ומובנה. נלמד על לולאות, פונקציות וכיצד להשתמש בהן בצורה יעילה ומובנת. נלמד גם על כלים נוספים שיעזרו לנו לכתוב קוד נקי וקל להבנה.


הצורך בשמירה על הקוד תמציתי הוא כפול - כתיבה כזו היא גם יעילה ומהירה יותר לכתיבה ומאפשרת לנו לבצע בקוד תיקונים ושינויים בצורה נוחה, והיא גם חשובה כדי שיהיה לנו קל יותר להבין את הקוד שכתבנו כשנחזור אליו במועד עתידי.

היחידה מכילה מספר נושאים:

 לולאות קוד
 
 פונקציות
 
 הערות, חלוקה לפרקים וכיפולי קוד
 
 שמירה וייצוא תוצאות
 
 יצירת מסמכים בRmarkdown


## לולאות

אחד העקרונות המנחים החשובים ביותר בכתיבה של קוד יעיל הוא הימנעות מחזרה על אותו הקוד מספר פעמים. 
  
  
אם, למשל, אנחנו מעוניינים לעשות את אותה הבדיקה על ארבעה שאלונים שונים - אנחנו נרצה להימנע מלכתוב את הקוד שמבצע את הבדיקה ארבע פעמים, כשההבדל היחיד בין החזרות הוא בשם השאלון.

במקום זאת נוכל להשתמש בלולאת קוד.


### הגדרת לולאה

לולאת קוד מוגדרת בצורה הבאה:

```{r,eval=FALSE}
for (object in vector){
  # Do stuff with each object
  
}
```

למשל:

```{r}
for (i in c("a","b","c")){
  # Do stuff with each object
  print(i)
}
```

אפשר להבחין בשני חלקים נפרדים בקוד:

  **1. הגדרת האובייקטים שישתתפו בלולאה:** השורה שפותחת את הלולאה (`for (i in c("a","b","c"))`) מגדירה על אילו אובייקטים אנחנו רוצים שהלולאה תרוץ. במקרה שלנו מדובר באיברים של הוקטור `c("a","b","c")`. הלולאה תרוץ על כל אחד מהאיברים, לפי הסדר, ותייצג אותם בתור `i`.

  **2. הגדרת הלולאה עצמה:** חלק זה תחום בתוך הסוגריים המסולסלים `{}` שבאים מיד אחרי הגדרת האובייקטים של הלולאה וכולל את הקוד שיתבצע בכל סבב שלה.

  
במקרה הנ"ל התוכנה תיקח את האיבר הראשון של הוקטור `c("a","b","c")`, תציב אותו בתור `i` ותבצע את הקוד שנמצא בתוך הסוגריים המסולסלים - תדפיס את ערכו ("a").
  
אחרי שסיימה לבצע את הסבב הראשון של הלולאה התוכנה תחזור לתחילת הלולאה, תציב בתור `i` את האיבר השני בוקטור - האות "b", ותבצע את הלולאה שוב. הפעם היא תדפיס "b".

בסבב השלישי התוכנה תציב ב`i` את האיבר השלישי בוקטור - "c", ותדפיס "c".



`תרגיל`
השלימו את הקוד בלולאה הבאה כך שידווח על הציונים של כל משתתף. בכל חזרה של הלולאה אנחנו נרצה שהיא תיגש לשורה אחרת בטבלה שלנו (לפי מספר הסבב), תשלוף את השם ואת הציון של הנבדק שאותה שורה מייצגת ותדפיס דיווח על הציון של אותו הנבדק.



```{r loops_ex1 ,exercise=TRUE, exercise.eval = FALSE}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = __________
  
  # get score
  score = _________
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```


הלולאה תעבור על כל הערכים בוקטור `1:nrow(data)` (במקרה הזה, המספרים מ1 עד 4) ותשמור את הערך כ`i`.
נשתמש בערך זה כדי לשלוף את השם ואת הציון של הנבדק בשורה המתאימה בכל סבב של הלולאה.



### דוגמא נוספת

 בדרך כלל נרצה שהלולאות יעשו יותר מאשר רק לשלוף ולהדפיס ערכים. התבוננו בלולאה הבאה ונסו להבין את מטרתה:
 
 
```{r ,eval=FALSE}
Questionaires = c("anxiety","depression","stress")
 
for (q in Questionaires){
  fitlered_data = data %>% filter(Questionaire == q)               # filter data
  plot = ggplot(fitlered_data, aes(x = score)) + geom_histogram()  # create plot
   
  filename = paste0(q, ".png")                                     # create filename
  ggsave(filename, plot)                                           # save plot as image
}
 
```

לולאה זו מדגימה שאפשר להשתמש בכל שם שנרצה עבור האיבר שמשתנה בכל סבב של הלולאה. במקרה הנ"ל קראנו לו `q` והשתשמשנו בו תחת שם זה לאורך הלולאה.


```{r loops_q1, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("הלולאה מחשבת את הממוצע של ציוני המשתתפים בכל שאלון",
                message = "נסו שוב. שימו לב שהלולאה אינה מבצעת אף חישוב על הנתונים"),
         answer("הלולאה מייצרת תרשים המשווה בין הציון הממוצע בכל שאלון",
                message = "נסו שוב. שימו לב שהלולאה מייצרת תרשים נפרד בכל סבב"),
         answer("הלולאה מייצרת שלושה עותקים של אותו התרשים, המכיל את פיזור הציונים בשלושת השאלונים",
                message = "נסו שוב. שימו לב שבכל סבב של הלולאה התרשים שנוצר מתבסס על נתונים אחרים"),
         answer("הלולאה מייצרת תרשים נפרד עבור פיזור הציונים בכל שאלון ושומרת אותו כתמונה", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה. בהרצה הראשונה הסרנו את העמודה - ולכן בהרצה השנייה היא כבר לא קיימת ומתקבלת הודעת שגיאה", 
  incorrect = "נסו שוב"
)
```


### תרגיל בניית לולאה

`תרגיל`
צרו לולאה ***


### שמירת תוצרי הלולאה


לעיתים קרובות נרצה לשמור את תוצרי הלולאה באובייקט חדש. נוכל לעשות זאת באמצעות הגדרת אובייקט חדש והשמה של הערך של האיבר בתוך הלולאה לאובייקט זה. ישנן שני דרכים עיקריות כדי לבצע פעולה שכזו:

1) לייצר אובייקט ריק (למשל - וקטור ריק) ולהוסיף אליו איברים בכל סבב של הלולאה
2) לייצר אובייקטה המלא בערכים חסרים ולהחליף את ערכים אלו בכל סבב של הלולאה

`תרגיל`

צרו לולאה שמחשבת את הממוצע של כל קבוצה של נתונים בקובץ המצורף. השתמשו בשיטה הראשונה לשמירת התוצרים של הלולאה. ***



### טעינת נתונים


```{r ,eval=FALSE}

data_file_names = c("data_1", "data_2", "data_3")

df = data.frame(id = c(), 
                score = c(),
                age = c(),
                source = c())

for (i in 1:nrow(data)){
  temp_df = read.csv(paste0("folder/",file_name,".csv"))
  temp_df = temp_df %>%
    mutate(source = file_name)
  
  df = bind_rows(df, temp_df)
}

 
```


```{r loops_q2, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("",
                message = "נסו שוב. "),
         answer("",
                message = "נסו שוב."),
         answer("",
                message = "נסו שוב."),
         answer("", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה. ", 

)
```


### לולאות בתוך לולאות

**

### שימוש בלולאות לטובת סימולציות

שימוש חשוב נוסף של לולאות קורא כשאנחנו רוצים לייצר סימולציות המכילות מספר רב של חזרות על תהליך שמכיל אקראיות. במקרים כאלו הלולאה עוזרת לנו לבצע את אותה הפעולה מספר רב של פעמים ולשמור את תוצרי הסימולציה באובייקט חדש.

נפגוש ונתרגל שימוש כזה ביחידת הלימוד הבאה, העוסקת בסימולציות בR.


## פונקציות

דרך נוספת בה אנחנו יכולים לעשות שימו חוזר באותו הקוד כוללת הגדרה של פונקציות.

מבחינה רעיונית, שיטה זו דומה מאוד לשימוש בלולאות - אבל במקום להריץ את הקוד שבלולאה מספר פעמים ברצף אנחנו אורזים אותו לשימוש עתידי כך שנוכל להשתמש בו מתי שיהיה לנו צורך בכך.

בניגוד ללואלות, פונקציות מכילות 2 חלקים נוספים:

1) הגדרת הארגומנטים שהפונקציה מקבלת
2) הגדרת הערכים שהפונקציה מחזירה

### הגדרת ארגומנטים

* כמו הi בלולאות

### החזרה

* הפונקציה היא סביבה נפרדת - והיא לא מייצרת איברים חדשים
* מה שנרצה להחזיר, יצטרך להכנס בתוך return

### דוגמא

* הדגמה פשוטה

* תרגיל פשוט

* הדגמה מורכבת יותר

* תרגיל מורכב יותר


## ניהול קבצי קוד 

חשיבות שמירת קוד מסודר ומובנה + הערות

### חלוקה לפרקים וקיפולי קוד

### שימוש במספר קבצי קוד נפרדים

* הגדרת פונקציות בקובץ נפרד
* ניתוח ראשוני - שמירת קבצים - ניתוח משני - תרשימים

#### ניקוי סביבת העבודה ושמירת אובייקטים

## ייצוא תוצאות

* אפשר להריץ מחדש את הקובץ, לייצר את התרשימים, להדפיס את הערכים ולשמור אותם
* אפשר גם לייצא את התרשימים והערכים כקבצים חיצוניים
* ניתן להשתמש בפונקציות כמו `ggsave` ו- `write.csv` כדי לשמור את התוצאות

### Rmarkdown

דרך נוספת, המאפשרת לייצר קבצים ישירות מתוך R. מאפשרת עיבוד בסיסי (למרות סמומלץ לעשות את רוב העיבוד מראש) והדפסה של תוצאות ותרשימים - וייצאו באופן מסודר. 

הפנייה למקורות מידע נוספים ללימוד עצמאי

## הגשה
  עברו על הקובץ וודאו שהגשתם את כל התרגילים ועניתם על כל השאלות
  
  במידה וכל התשובות שלכם תקינות יש ללחוץ על הכפתור:  Generate, להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```