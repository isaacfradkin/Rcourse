---
title: "Lesson 9: Loops and Efficiant Coding" 
author: "Copyright 2024 Psychology Department. Hebrew University of Jerusalem. All rights reserved"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false


description: >
 <div style='direction: rtl;'>
 
 </div>
       
runtime: shiny_prerendered  
editor_options: 
  markdown: 
    wrap: 72
---

```{=html}
<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
.text-block1 {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #e7f3fe; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ddd; /* Light border */
  margin: 10px 0; /* Space around the block */
}


.extra_functions {
  direction: rtl;       /* Set text direction to right-to-left */
  text-align: right;
  background-color: #e7f3fe; /* Light grey background */
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ddd; /* Light border */
  margin: 10px 0; /* Space around the block */
}


</style>
```

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(Rcourse)
library(ggplot2)
library(tidyverse)

knitr::opts_chunk$set(error = TRUE)
gradethis::gradethis_setup()


df = data.frame(subject = rep(c("Bruce","Jemima","Chanique","Marvin"),each = 10),
                score = rep(c(70,80,85,75),each = 10) + rnorm(40,0,5))

{
  slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
intercepts = c(2, 3, 1, 2.5, 3.5)
names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

social_sleep  = data.frame()

for (i in 1:5){
  name = names[i]
  slope = slopes[i]
  intercept = intercepts[i]
  
  sleep = rnorm(30, 7, 1)
  social = slope*sleep + intercept + rnorm(30, 0, 1)
  
  temp_df = data.frame(name = name, sleep = sleep, social = social)
  social_sleep = bind_rows(social_sleep, temp_df)
}

social_sleep  = social_sleep  %>% mutate(sleep = round(sleep,1),
                                         social = round(social))
} # social sleep
```

```{r prepare-social_sleep}

slopes = c(0.5, 0.7, 0.3, 0.6, 0.8)
intercepts = c(2, 3, 1, 2.5, 3.5)
names = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

social_sleep  = data.frame()

for (i in 1:5){
  name = names[i]
  slope = slopes[i]
  intercept = intercepts[i]
  
  sleep = rnorm(30, 7, 1)
  social = slope*sleep + intercept + rnorm(30, 0, 1)
  
  temp_df = data.frame(name = name, sleep = sleep, social = social)
  social_sleep = bind_rows(social_sleep, temp_df)
}

social_sleep  = social_sleep  %>% mutate(sleep = round(sleep,1),
                                         social = round(social))
```

```{r prepare-func1}
mystery_function <- function(celsius) {
    fahrenheit <- (celsius * 9/5) + 32
    return(fahrenheit)
}
```

```{r prepare-func2}
mystery_function_2 <- function(x, value) {
    below <- sum(x < value)
    equal <- sum(x == value)
    n <- length(x)
    return((below + 0.5 * equal) / n * 100)
}
```

## מבוא

ביחידה זו נלמד על מספר טכניקות חשובות לקידוד מסודר ואפקטיבי. במהלך
היחידה נלמד על לולאות ופונקציות וכיצד להשתמש בהן כדי לכתוב קוד יעיל
ותמציתי, נעבור על מספר המלצות לניהול קבצי קוד מורכבים ונגע במספר
פרקטיקות המסייעות בניהול של ניתוחים ארוכים ותוצאותיהן.

שמירה על קוד תמציתי חשובה משתי סיבות: ראשית, כתיבה תמציתית היא יעילה
ומהירה יותר ומאפשרת תיקונים ושינויים בנוחות. שנית, היא מסייעת לנו להבין
את הקוד בצורה טובה יותר כשנחזור אליו בעתיד ולזהות טעויות באופן יותר
יעיל.

ייתכן שלחלקכם נושאים אלו נשמעים כשוליים בחשיבותם לקידוד עצמו, אבל כבר
בפרויקט הקידוד הראשון שלכם אתם צפויים לגלות שהם חיוניים עבור כל ניתוח
שתבצעו לא פחות מאשר הקוד עצמו.

הנושאים שנלמד ביחידה זו כוללים:

-   לולאות קוד

-   פונקציות

-   הערות, חלוקה לפרקים וקיפולי קוד

-   שמירה וייצוא תוצאות

-   יצירת מסמכים בRmarkdown

## לולאות

עקרון מנחה חשוב בכתיבת קוד יעיל הוא הימנעות מחזרה על קוד מספר פעמים.

אם, למשל, אנחנו מעוניינים לעשות את אותה הבדיקה על ארבעה שאלונים שונים -
אנחנו נרצה להימנע מלכתוב את הקוד שמבצע את הבדיקה ארבע פעמים, כאשר ההבדל
היחיד בין החזרות הוא שם השאלון.

במקום זאת נוכל להשתמש בלולאה.

### הגדרת לולאה

לולאת קוד מוגדרת בצורה הבאה:

```{r loop_example,eval=FALSE}
for (object in vector){
  # Do stuff with each object
  
}
```

למשל:

```{r loop_example_2}
for (i in c("a","b","c")){
  print(i)
}
```

::: text-block1
הלולאה מורכבת משני חלקים:

**1. הגדרת הלולאה:** שורת הפתיחה של הלולאה (`for (i in c("a","b","c"))`)
מגדירה על אילו אובייקטים אנחנו רוצים שהלולאה תרוץ. במקרה שלנו מדובר
באיברים של הוקטור `c("a","b","c")`. הלולאה תרוץ על כל אחד מהאיברים, לפי
הסדר, ותייצג כל אחד מהם בתורו באמצעות `i`.

**2. הגדרת הלולאה עצמה:** חלק זה תחום בתוך הסוגריים המסולסלים `{}` שבאים
מיד אחרי הגדרת הלולאה וכולל את הקוד שיתבצע בכל סבב שלה.
:::

במקרה הנ"ל התוכנה תיקח את האיבר הראשון של הוקטור `c("a","b","c")`, תציב
אותו בתור `i` ותבצע את הקוד שנמצא בתוך הסוגריים המסולסלים - תדפיס את
ערכו ("a").

לאחר השלמת הסבב הראשון, התוכנה תחזור לתחילת הלולאה, תציב בתור `i` את
האיבר השני בוקטור - האות "b", ותבצע את הלולאה שוב. הפעם היא תדפיס "b".

בסבב השלישי התוכנה תציב ב`i` את האיבר השלישי בוקטור - "c", ותדפיס "c".

לאחר שסיימה לעבור על כל הערכים בוקטור, הלולאה תסתיים והתוכנה תעבור לבצע
את קטע הקוד הבא שביקשנו ממנה להריץ).

`תרגיל`

השלימו את הקוד בלולאה הבאה כך שידווח על הציונים של כל משתתף. בכל חזרה של
הלולאה אנחנו נרצה שהיא תיגש לשורה אחרת בטבלה שלנו (לפי מספר הסבב), תשלוף
את השם ואת הציון של הנבדק שאותה שורה מייצגת ותדפיס דיווח על הציון של
אותו הנבדק.

```{r loops_ex1, exercise=TRUE, exercise.eval = FALSE}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = __________
  
  # get score
  score = _________
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```

```{r loops_ex1-solution}

data = data.frame(name = c("David","Pnina","Yossi","Rina"),
                  score = c(80,90,70,85))

for (i in 1:nrow(data)){
  # get name
  name = data$name[i]
  
  # get score
  score = data$score[i]
  
  report = paste(name, "Scored",score,"points")
  print(report)
}
 
```

```{r loops_ex1-check}

grade_this({
  if (identical(.evaluate_result,evaluate::evaluate(.solution))) {
    pass("מעולה")
  }
  fail("נסו שוב")
})

```

\@\@ problem with checker function


הלולאה תעבור על כל הערכים בוקטור `1:nrow(data)` (במקרה הזה, המספרים מ1
עד 4) ותשמור את הערך כ`i`. נשתמש בערך זה לשליפת השם והציון של הנבדק
בשורה המתאימה בכל סבב של הלולאה.


::: extra_functions
הפונקציות `paste` ו`paste0` משמשות כדי לחבר יחד מחרוזות (מילים, אותיות). בדוגמה הקודמת הפונקציה משלבת את שם הנבדק והציון שלו לכדי משפט קוהרנטי.

ההבדל בין הפונקציות הוא בכך ש`paste` מוסיפה רווחים בין המחרוזות שהיא מחברת ואילו `paste0` לא מוסיפה רווחים
:::

### דוגמא נוספת

בדרך כלל נרצה שהלולאות יעשו יותר מאשר רק לשלוף ולהדפיס ערכים. התבוננו
בלולאה הבאה ונסו להבין את מטרתה:

```{r loop_example_3,eval=FALSE}
Questionaires = c("anxiety","depression","stress")
 
for (q in Questionaires){
  fitlered_data = data %>% filter(Questionaire == q)               # filter data
  plot = ggplot(fitlered_data, aes(x = score)) + geom_histogram()  # create plot
   
  filename = paste0(q, ".png")                                     # create filename
  ggsave(filename, plot)                                           # save plot as image
}
 
```


```{r loops_q1, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה?
         </div>",
         
         answer("הלולאה מחשבת את הממוצע של ציוני המשתתפים בכל שאלון",
                message = "נסו שוב! שימו לב שהלולאה אינה מבצעת חישובים על הנתונים"),
         answer("הלולאה מייצרת תרשים המשווה בין הציון הממוצע בכל שאלון",
                message = "נסו שוב! שימו לב שהלולאה מייצרת תרשים נפרד בכל סבב"),
         answer("הלולאה מייצרת שלושה עותקים של אותו התרשים, המכיל את פיזור הציונים בשלושת השאלונים",
                message = "נסו שוב! שימו לב שבכל סבב של הלולאה התרשים שנוצר מתבסס על נתונים אחרים"),
         answer("הלולאה מייצרת תרשים נפרד עבור פיזור הציונים בכל שאלון ושומרת אותו כתמונה", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה. בכל סבב של הלולאה היא חותכת מתוך הטבלה את השורות הרלוונטיות לשאלון, מייצרת היסטוגרמה עבור ציוני שאלון זה, מייצרת את שם הקובץ על סמך שם השאלון ושומרת בשם זה את התרשים.", 
  incorrect = "נסו שוב"
)
```


שימו לב שאפשר להשתמש בכל שם שנרצה עבור האובייקט שמשתנה בכל סבב של
הלולאה. במקרה הנ"ל קראנו לו `q` והשתמשנו בו תחת שם זה לאורך הלולאה.


### שמירת תוצרי הלולאה

לעיתים קרובות נרצה לשמור את תוצרי הלולאה באובייקט כלשהו. נוכל לעשות זאת
באמצעות הגדרת אובייקט חדש שאליו נוסיף את הערכים שחישבנו בכל סבב של הלולאה. 

נמחיש באמצעות מספר דוגמאות:


הוספת התוצאה לסוף הוקטור באמצעות הפונקציה `c()`

```{r loops_save_example,  exercise=TRUE, exercise.eval = FALSE}
# וקטור ריק
results = c()

subjects = df$subject %>% unique() # וקטור המכיל את שמות / מספרי הנבדקים
                                   # כשכל שם מופיע רק פעם אחת
for (subj in subjects){
  subj_data = df %>% filter(subject == subj) # שליפת נתוני הנבדק
  subj_mean = subj_data %>%                  # חישוב הציון הממוצע
    pull(score) %>%
    mean() 
  
  results = c(results, subj_mean)  # הוספת ממוצע הנבדק לוקטור התוצאות
}

print(results)
```


הוספת תוצאות לוקטור באמצעות []

```{r loops_save_example_2,  exercise=TRUE, exercise.eval = FALSE}
# וקטור ריק
results = c()

subjects = df$subject %>% unique() # וקטור המכיל את שמות / מספרי הנבדקים
                                   # כשכל שם מופיע רק פעם אחת
for (i in 1:length(subjects)){
  subj_data = df %>% filter(subject == subjects[i]) # שליפת נתוני הנבדק
  subj_mean = subj_data %>%                         # חישוב הציון הממוצע
    pull(score) %>%
    mean() 
  
  results[i] =  subj_mean  # הוספת ממוצע הנבדק לוקטור התוצאות
}

print(results)
```


הוספת התוצאות לטבלה ריקה באמצעות `bind_rows`

```{r loops_save_example_3,eval=FALSE}

data_file_names = c("data_1", "data_2", "data_3")

df = data.frame()   # טבלה ריקה

for (file_name in data_file_names){
  temp_df = read.csv(paste0("folder/",file_name,".csv"))
  temp_df = temp_df %>%
    mutate(source = file_name)  # הוספת עמודה המציינת את מקור הנתונים
  
  df = bind_rows(df, temp_df)   # הפונקציה תצרף לטבלה שורות חדשות בכל סבב
}
```


```{r loops_q2, echo = FALSE}
question("<div style='direction: rtl;'>
מה מבצעת הלולאה בקטע הקוד האחרון?         </div>",
         
         answer(" לגיל הנבדק",
                message = "נסו שוב. "),
         answer("הלולאה ייצרת טבלה עם ארבע עמודות, מפצלת ושומרת אותה בשלושה קבצים נפרדים",
                message = "נסו שוב."),
         answer("מייצרת שלושה טבלאות נפרדות, ושומרת אותן בהתאם לשם הקובץ ממנו יובאו",
                message = "נסו שוב."),
         answer("טוענת טבלאות משלושה קבצים ומאחדת אותן לטבלה אחת", correct = TRUE),
         allow_retry = TRUE,
         
         
  correct="תשובה נכונה", 

)
```

### תרגיל בניית לולאה

הנתונים בטבלה `social_sleep` מתארים את שעות השינה וציוני החברתיות עבור 5
נבדקים בכל יום במשך חודש.

```{r, echo = F}
head(social_sleep)
```

`תרגיל` צרו לולאה המחשבת עבור כל נבדק את המתאם בין שעות השינה והחברותיות
באותו היום. היעזרו בפונקציה `cor` המחשבת את המתאם בין שני וקטורים של
מספרים.

```{r loops_ex2, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-social_sleep"}

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# כתבו כאן את הלולאה




# יצירת תרשים על סמך התוצאות
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+
  ylab("Correlation")

```

```{r loops_ex2-solution}

subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

correlations = c()

# בנו את הלולאה כאן

for (subj in subjects){
  subj_data = social_sleep %>% filter(name == subj)
  r = cor(subj_data$sleep, subj_data$social)
  correlations = c(correlations, r)
}


# יצירת תרשים על סמך התוצאות
ggplot(data.frame( name = subjects,
                   r = correlations))+
  geom_col(aes(x = name, y = r), fill = "skyblue")+
  ylab("Correlation")
```

```{r loops_ex2-check}
if (identical(user_object_get("correlations"),
              solution_object_get("correlations"))){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }

```

### לולאות בתוך לולאות

את התרגיל הקודם יכולנו לפתור גם באמצעות הכלים שלמדו בסמסטר בקודם - באמצעות
הפונקציות `group_by` ו `summarise`. לעומת זאת, לולאות מאפשרות לנו גם
לבצע ניתוחים נוספים, שאינם אפשריים (או אינם נוחים) בכלים שלמדנו קודם.

למשל, יתכן ונרצה להשוות בין כל צמד משתתפים ולבחון את המתאם בין הציונים
שלהם. נוכל לעשות זאת באמצעות לולאה שנמצאת בתוך לולאה אחרת:

הלולאה הראשונה תעבור על שמות הנבדקים, ותערוך השוואה של הנבדק אלו מול כל
שאר הנבדקים (כולל עצמו) באמצעות לולאה נוספת.

```{r nested_loops_example, exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-social_sleep"}

print(head(social_sleep)) # הצצה אל תוך קובץ הנתונים


subjects = c("Yocheved","Alfred","Dilan","Shoshkeh", "Noam")

df = data.frame(subj1 = c(), # טבלה ריקה 
                subj2 = c(),
                r = c())

for (subj1 in subjects){
  for (subj2 in subjects){
      subj1_social = social_sleep %>% filter(name == subj1) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק אחד
      subj2_social = social_sleep %>% filter(name == subj2) %>% pull(social) # וקטור המכיל את דירוגי החברתיות של נבדק נוסף
      
      r = cor(subj1_social, subj2_social) # נחשב את המתאם בין דירוגי החברותיות
      
      new_row = data.frame(subj1 = subj1, # נסדר את שמות הנבדקים שביניהם חישבנו את המתאם
                           subj2 = subj2,
                           r = r)         # ואת מקדם המתאם שקיבלנו  בתור שורה בטבלה
      
      df = bind_rows(df, new_row)         # נצרף את השורה שיצרנו לטבלה הכללית
  }
}

# הצגת המתאמים באמצעות תרשים חום
# ככל שהמתאם חזק יותר - צבע הרקע חזק יותר (בהתאם לכיוון המתאם)
ggplot(df, aes( x = subj1, y = subj2))+
  geom_tile(aes(fill = r))+
  geom_text(aes(label = round(r,2)), color = "white")+
  scale_fill_gradient2(low = "red", high = "blue")+
  theme_minimal()

```

### שימוש בלולאות לטובת סימולציות

שימוש חשוב נוסף של לולאות מאפשר לנו לייצר הדמיה (או בלעז- סימולציה) של תהליכים המכילים
אקראיות. במקרים כאלו נרצה לחזור שוב ושוב על התהליך כדי לגבש הבהנה טובה
יותר של התפלגות התוצאות שאנחנו צפויים לקבל.

למשל, נוכל לבצע סימולציה כדי לבדוק את התפלגות הערכים הצפויים עבור סכומם
של שתי הטלות קובייה.

```{r simulation_cube}
results = c()
n_iterations = 10000

for (i in 1:n_iterations){ # נחזור על התהליך 1000 פעם
  result1 = sample(x = 1:6, size = 1) # הטלה ראשונה: נדגום אקראית מספר מ1 עד 6
  result2 = sample(x = 1:6, size = 1) # הטלה שנייה: נדגום מספר נוסף
  sum_of_both = result1 + result2 # נחשב את סכום את 2 ההטלות
  
  results[i] = sum_of_both # נוסיף את הסכום שקיבלנו לוקטור
}

results_sum = data.frame(value = results) %>%
  group_by(value) %>% 
  summarise(n = n(),
            percent =n/n_iterations)


ggplot(results_sum, aes( x = factor(value), y = percent))+
  geom_col()+
  scale_y_continuous()

print(results_sum)
```

ענו על השאלה הבאה על סמך תוצאות הסימולציה:

```{r loops_q3, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה הסיכוי (בקירוב) להטיל שתי קוביות שסכום תוצאות ההטלה שלהן הוא 3?
  </div>",
  answer("25%"),
  answer("15%"),
  answer("10%"),
  answer("5%", correct = TRUE),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

ביחידה הבאה נלמד בצורה מעמיקה יותר על סימולציות, השימושים השונים בהם
ואיך עורכים אותן.

## פונקציות

דרך נוספת בה אנחנו יכולים לעשות שימוש חוזר באותו הקוד כוללת הגדרה של
פונקציות.

מבחינה רעיונית, שיטה זו דומה מאוד לשימוש בלולאות - אבל במקום להריץ את
הקוד שבלולאה מספר פעמים ברצף אנחנו "אורזים" אותו לשימוש עתידי כך שנוכל
להשתמש בו בצורה נוחה מתי שיהיה לנו צורך בכך, במקום לכתוב מחדש את כל קטע
הקוד.

הגדרה של פונקציה תיראה כך:

```{r functions_example}
my_function = function(a,b){
  # do stuff
  c = a+b
  
  return (c)
}

#שימוש בפונקציה
result = my_function(1,2)

```

בניגוד ללולאות, פונקציות מכילות 2 חלקים נוספים:

1)  הגדרת הארגומנטים שהפונקציה מקבלת: בדוגמה הנ"ל הפונקציה מצפה לקבל
    מאיתנו 2 ערכים, אותם היא מכנה `a` ו`b`.
2)  הגדרת הערכים שהפונקציה מחזירה: חלק זה יקבע את התוצר שנקבל כשנשתמש
    בפונקציה בדוגמה הנ"ל הפונקציה מחזירה את הסכום של שני המספרים שהיא
    קיבלה מאיתנו.

שימו לב: בניגוד ללולאות, אובייקטים שנייצר בתוך פונקציה לא יישמרו. התוצר
היחיד שנקבל מהפונקציה הוא הערך שהפונקציה מחזירה.

### דוגמא

לפניכם קוד המגדיר פונקציה. נסו להבין את מטרתה.

```{r functions_example_2}
mystery_function <- function(celsius) {
    fahrenheit <- (celsius * 9/5) + 32
    return(fahrenheit)
}
```

```{r guess_function_1,exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-func1" }

mystery_function( celsius = 200)

mystery_function( celsius = c(150, 175, 200, 225, 250))

```

```{r functions_q4, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה מטרתה של הפונקציה?
  </div>",
  answer("המרה של טמפרטורה ממעלות פרנהייט למעלות צלזיוס"),
  answer("המרה של טמפרטורה ממעלות צלזיוס למעלות פרנהייט", correct = TRUE),
  answer("המרת נתוני טמפרטורה מטבלה לוקטור"),
  answer("שמירת נתוני הטמפרטורה כטבלה"),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

### תרגיל כתיבת פונקציה

כתבו פונקציה המקבלת וקטור של מספרים ומחזירה אותו בתור ציוני תקן.

```{r func_exercise,exercise=TRUE, exercise.eval = FALSE }
Z_score_function = # כתבו את הפונקציה כאן
  # הפונקציה צריכה לקבל וקטור 
  # לחשב את הממוצע וסטיית התקן שלו
  # ואז לחשב את ציוני התקן
  # זכרו: ציוני תקן מחושבים כך: (ערך - ממוצע) / סטיית תקן
  
  # אל תשכחו להחזיר את וקטור ציוני התקן באמצעות
  # return
  # בסוף הפונקציה
  
  
  
# השאירו את שורת הקוד הבאה כפי שהיא
# השורה מיישמת את הפונקציה על וקטור ומדפיסה את התוכן שלו 
test_vector = 1:10
z_test_vector = Z_score_function(test_vector)
print(z_test_vector)
  
```

```{r func_exercise-solution}
Z_score_function = function(vec){
  z = (vec - mean(vec)) / sd(vec)
  
  return (z)
}
  
  
# השאירו את שורת הקוד הבאה כפי שהיא
# השורה מיישמת את הפונקציה על וקטור ומדפיסה את התוכן שלו 
test_vector = 1:10
z_test_vector = Z_score_function(test_vector)
print(z_test_vector)
```

```{r func_exercise-check}
if (identical(user_object_get("z_test_vector"),
                 solution_object_get("z_test_vector"))){
     pass("עבודה מצוינת!")
   } else {
     fail("ישנה טעות בקוד. נסו שוב")
   }
```

### דוגמה נוספת

התבוננו בדוגמה הבאה ונסו להבין את ייעודה של הפונקציה:

```{r functions_example_3}
mystery_function_2 <- function(x, value) {
    below <- sum(x < value)
    n <- length(x)
    return((below) / n * 100)
}

```

```{r guess_function_2,exercise=TRUE, exercise.eval = FALSE, exercise.setup = "prepare-func2" }

mystery_function_2( x = 1:10, value = 5)

```

```{r functions_q5, echo = FALSE}

question(
  "<div style='direction: rtl;'>
  מה הפונקציה מבצעת?
  </div>",
  answer("חישוב הממוצע של וקטור"),
  answer("סינון ערכים הקטנים מערך נתון מתוך וקטור מספרי"),
  answer("חישוב אחוז הערכים הקטן מערך נתון בוקטור מספרי", correct = TRUE),
  answer("המרת וקטור עם נתוני שכיחות לאחוזים"),
  allow_retry = TRUE,
  
  correct="מעולה!", 
  incorrect = "נסו שוב"
)

```

`תרגיל`

תקנו את הקוד של הפונקציה הבאה כך שהפונקציה תעבוד בצורה תקינה:

```{r no_return, rexercise=TRUE, exercise.eval = FALSE}
limit_range <- function(vec, limits){
  # הפונקציה מקבלת וקטור מספרי
  # ווקטור נוסף המכיל 2 ערכים המשווים את קצוות הטווח הרצוי
  # ומחזירה וקטור שבו הערכים שהיו מחוץ לטווח מוחלפים בערכים חסרים
  
    out_of_limits = vec < limits[1] | vec > limits[2]
    vec[out_of_limits] = NA
}

test_vector = 1:10
test_limits = c(3,7)
print(limit_range(vec = test_vector, limits = test_limits))

```

```{r no_return-hint-1}
האם הפונקציה מחזירה ערך כלשהו באמצעות הפקודה return?
```

## ניהול קבצי קוד

הנושא האחרון שנגע בו ביחידה זו נוגע לניהול של קבצי קוד. נתייחס לכתיבה
מסודרת של קוד, קיפול קוד והערות ולחלוקת הקוד על פני מספר קבצים.

### חלוקה לפרקים וקיפולי קוד

סביר להניח שבעבודה שלכם עם R עד כה נתקלתם כבר בהבנה שהקוד שאתם כותבים
יכול בקלות להפוך למסורבל וקשה להבנה. במקרים כאלו, לא רק שיהיה לנו יותר
קשה לחזור לקוד שלנו ולהבין מה הוא עושה - אלא גם יהיה קשה מאוד למצוא
טעויות, להוסיף שינויים לקוד ולעבוד עליו יחד עם אנשים נוספים.

בפרק הזה נכיר לכם כמה כלים פשוטים שמסייעים לנו לשמור על קוד מסודר ונגיש:
כתיבת הערות, חלוקה לפרקים וקיפולי קוד

#### הערות

את ההערות כבר פגשתם במהלך הקורס מספר רב של פעמים. הערות הן חלק מהקוד
שאינו מבוצע עליו כל פעולה ומיועד להסבר על הקוד ועל הפעולות שבוצעו בו.
הערות נכתבות באמצעות הסימן `#` וניתן להשתמש בהן כדי להסביר פעולות שבוצעו
בקוד, להסביר קטעי קוד ולהזכיר לעצמנו פעולות שיש לבצע בעתיד.

השימוש בהן פשוט, ועל אף שהוספת ההערות לוקחת זמן ומאיטה את הכתיבה - מאוד
מומלץ לסגל הרגל של הוספת הערות על כל שורה ושורה. זה יעזור לכם לסדר את
מהלך הניתוח עבור עצמכם, יאפשר לכם להבין בקלות מה הקוד שכתבתם נועד לעשות
ויסייע לכם למצוא טעויות בקוד.

#### חלוקה לפרקים

הכלי הבא כולל הוספה של כותרות בין חלקי הקוד השונים, וגם הוא מתבצע
באמצעות סימן ה`#`.

הוספה של 4 סולמיות ומעלה בסוף הערה תהפוך את ההערה לכותרת. אם נלחץ לצד
הכותרת נסתיר את הקוד שמופיע אחריה - עד לכותרת הבאה.

בקבצים ארוכים הדבר יאפשר לנו לעקוב אחרי המטרה של כל חלק בקוד ולהסתיר את
החלקים שלא משמשים אותנו באותו הרגע. בנוסף, בRstudio , נוכל לנווט בין
הכותרות השונות באמצעות כפתור שמופיע בצד השמאלי של תחתית חלון הקוד או
באמצעות חלונית הניווט, ותה ניתן לפתוח באמצעות כפתור ה"Outline" שבפינה
הימנית העליונה של המסך, או בעזרת קיצור המקלדת ctrl + shift + O.

העתיקו את הקוד הבא לRstudio ונסו בעצמכם.

```{r comments_example}
# זו הערה רגילה

# וזו כותרת #### 

example_code = 1:10 

# זו כותרת נוספת ####

more_example_code = example_code ** 2

```

#### קיפולי קוד נוספים

בקוד הנ"ל הכללנו שיטה נוספת לבצע קיפולי קוד - מבלי לייצר פרק חדש. לטובת
כך אנחנו משתמשים בסוגריים מסולסלים `{}`. סוגריים אלו שימוש אותנו בהגדרה
של לולאות ופונצקיות אבל אפשר להשתמש בהן גם בלעדיהן. נכניס את הקוד שאנחנו
מעוניינים לכפל לתוך הסוגריים - ובלחיצה משמאל לאחד מהסוגריים נסתיר את
הקוד שבתוכן. מומלץ להוסיף הערה לאחר הסוגר השני כדי לגלות לקוראים מה
מוסתר בתוך הסוגריים.

### שימוש במספר קבצי קוד נפרדים

מעבר להמלצות אלו, ניתן להפריד את הקוד שלנו למספר קבצים נפרדים. כך נוכל
להפריד בין פונקציות שונות, להפריד בין חלקי הניתוח שונים ולהפריד בין קוד
ראשי לבין קוד המפעיל ניתוחים נוספים.

זו פרקטיקה חשובה שמאפשרת לנו לשמור על הסדר בניתוחים שלנו.

אבל איך נעביר את המידע בין הקבצים?

אנחנו יכולים לפתוח את קבצי הקוד השונים שלנו ולהפעיל אותם בעצמנו בזה אחר
זה - אבל זו שיטה שנרצה להימנע ממנה כיוון שהיא מסורבלת ועלולה לייצר תקלות
כשנשכח להפעיל קוד מסוים. או שנפעיל את הקבצים בסדר לא נכון.

במקום זאת, נעדיף שכל קובץ יוכל להיות מופעל באופן עצמאי - ויעזר בקבצים
הקודמים על ידי ייבוא הקוד מהם או ייבוא של קבצים שיצרנו בהם.

בדרך כלל מערך קבצים של ניתוח ייראה בצורה הבא:

קובץ המכיל את כל הפונקציות הייעודיות שבנינו בעצמנו לטובת הניתוח. מאחר
והפונקציות יכולות להיות מורכבות, נעדיף להפריד אותן לקובץ נפרד.

קובץ המכיל הקוד האחראי לייבוא קבצי הנתונים שלנו ועיבודם לטובת הניתוחים
הסופיים והפקת התרשימים

קובץ תמציתי ומסודר המבצע את הניתוחים הסטטיסטיים ומפיק את התרשימים
הרלוונטיים.

העברת המידע בין הקבצים יכולה לקרות בכמה דרכים:

1.  כדי לייבא את הפונקציות שלנו מקובץ הפונצקיות נוכל להשתמש בפקודה
    `source(name_of_file.R")`. פקודה זו תריץ את הקובץ ששמו מצויין
    בסוגריים, כך שאם הוא מכיל פונקציות - פונקציות אלו יצורפו לסביבת
    העבודה שלנו.

2.  גם את הרצת קובץ הניתוח העיקרי נוכל לבצע בצורה דומה - אבל במידה והוא
    דורש ניתוח שעלול לקחת זמן להריץ נעדיף להימנע מכך. במקום זאת נוכל
    לשמור בסוף הקובץ את הטבלאות והאובייקטים הרלוונטיים ולייבא אותם מחדש
    בתחילת קובץ הניתוח הסופי. לגישה זו יש יתרון נוסף, שכן היא מאפשרת לנו
    לייבא לססביבת העבודה רק את האובייקטים הרלוונטיים ולהימנע ממצב בו
    סביבת העבודה מוצפת במספר רב של אובייקטים ארכאיים.

דרך אחת לעשות זאת כבר נלמדה בסמסטר א' - ייצוא טבלאות כקבצי CSV וייבואן
מחדש בקובץ הבא. זו גישה טובה ונוחה, אך היא מתאימה רק לטבלאות.

אם נרצה לשמור ולהעביר אובייקטים אחרים נוכל להשתמש בפקודה
`saveRDS(object, "name_of_file.rds")` ולייבא אותם באמצעות
`readRDS("name_of_file.rds")`. פקודות אלו מתאימות לכל אובייקט בR, מכל
סוג שהוא. הוא נשמר בפורמט ייעודי של R ומיובא בצורה זהה לאובייקט המקורי.

#### ניקוי סביבת העבודה ושמירת אובייקטים

כדי לשמור על סביבת העבודה שלנו נקייה נוכל להשתמש בפקודה
`rm(list = ls())`. פקודה זו תמחק את כל האובייקטים שנמצאים בסביבת העבודה
שלנו, ותשאיר אותה ריקה ונקייה.

הפקודה `rm` מקבלת רשימה של אובייקטים שאנחנו רוצים למחוק, כך שבמידה
ואנחנו מעוניינים למחוק את כל האובייקטים נשתמש בפקודה `ls()` שתחזיר לנו
את רשימת כל האובייקטים שנמצאים בסביבת העבודה שלנו.

לחלופין, ניתן לבצע את הפעולה הזו ידנית באמצעות כפתור המטאטא שבסרגל הכלים
שבראש חלונית שסביבת העבודה (Environment).

נכלול את שורת קוד זו בתחילת קבצי הR שלנו כדי לשמור על סביבת העבודה שלנו
נקייה ומסודרת.

## ייצוא תוצאות

השלב האחרון בתהליך עיבוד הנתונים כולל את ייצוא התוצרות. לאחר שהפקנו את
התרשימיםת ייצרנו את טבלאות הסיכום וביצענו את המסחנים הסטטיסטיים - נרצה
לייצא אותם לטובת דיווח או שיתוף התוצאות. יש כמה דרכים שנוכל לבצע זאת.

1.  באופן ידני:

נריץ את הקובץ, נפיק את התרשימים והניתוחים ונשמור את התוצאות אחת אחת.

2.  באמצעות פקודות המייצאות את התוצאות:

כדי לא לבצע את הפעולה ידנית נוכל לייצא את התוצאות על ידי מספר פונקציות
יעודיו:

את הטבלאות נוכל לשמור כקבצי CSV באמצעות הפקודה `write.csv`

את התרשימים נוכל לשמור באמצעות פונקציות כמו `ggsave` המייצאות את
התרשימים כקובץ תמונה

ואת הניתוחים הסטטיסטיים נוכל לייצא כטבלאות דיווח באמצעות מערך של
פונקציות המסדרות את התוצאות בטבלאות ושומרות אותן כקבצי וורד. קישור
לדוגמא. <https://rempsyc.remi-theriault.com/articles/t-test>

3.  באמצעות Rmarkdown

### Rmarkdown

Rmarkdown הוא כלי יעיל שמאפשר לנו לייצר מסמכים מעוצבים ומסודרים בקוד R.
באמצעות Rmarkdown נוכל לייצר דוחות סטטיסטיים, דפי ניתוח וגרפים ולשתף
אותם עם אחרים בצורה נוחה ומסודרת.

בשיטה זו נייצר קובץ Rmarkdown המכיל טקסט וכותורות שביניהם משובצים קטעי
קוד. נשתמש בקטעי קוד אלו כדי להפיק את התרשימים והטבלאות שאנחנו רוצים
להציג, ונשתמש בקטעי הטקסט כדי להסביר את התוצאות שלנו ולעזור לקורא לעקוב
אחרי מהלך הניתוח.

כשנסיים לייצר את הקובץ נוכל להפיק אותו באמצעות פעולה הנקראת "Knit",
ולקבל קובץ חדש המכיל את הטקסט והתוצאות שלנו. בצורה זו ניתן לייצר קבצי
וורד, PDF או קבצי html המכילים את התוצאות שלנו. בפורמט html נוכל אפילו
לכלול טבלאות ותרשימים אינטראקטיביים.

בתרגיל המסכם תפגשו דוגמה לקובץ שכזה, המדגים שימוש בכלים שנלמדו ביחידה
זו.

למידע נוסף על Rmarkdown ואופן השימוש בו תוכלו להשתמש במדריכים אינטרנטיים
רבים שקיימים ברשת, כגון:

[מדריך מסודר המלווה במספר דוגמאות](https://rmarkdown.rstudio.com/)

[קובץ PDF המסכם את הכלים הבסיסיים ליצירת קבצים
בRmarkdown](https://rmarkdown.rstudio.com/lesson-15.HTML)

[מדריך מקיף על השימוש בRmarkdown](https://bookdown.org/yihui/rmarkdown/)

[מדריך מקיף נוסף](https://r4ds.had.co.nz/r-markdown.html)

## תרגיל

![](images/Rstudio%20logo.png){width="100"}

כדי לתרגל את הנושאים שנלמדו ביחידה זו נבצע ניתוח הכולל שימוש בלולאות קוד
ופונקציות. ניתוח זה לא יהיה מורכב מדי, אך כדי לתרגל ניהול ניתוחים
מורכבים יותר נבצע אותו באמצעות מספר קבצים נפרדים, כפי שלמדנו ביחידה.

הורידו מהמודל את שלושת קבצי הקוד ואת שלושת קבצי הנתונים שבתיקיית "יחידה
9".

הוראות לתרגיל לפי קבצים:

"9_functions":

1.  צרו פונקציה המחשבת את גבולות רווח הסמך לממוצע של וקטור מספרי

2.  וודאו שהיא עובדת בצורה תקינה ושמרו אתהעריכות שביצעתם בקובץ

"9_main_analysis":

1.  ייבאו את קובץ הפונקציות באמצעות הפקודה `source`

2.  צרו לולאה המייבאת ומאחדת את את שלושת קבצי הנתונים.

3.  סכמו את את הנתונים בטבלה שיצרתם. עבור כל קבוצה, חשבו את הציון
    הממוצע, ואת הגבול העליון והתחתון לרווח הסמך לממוצע (באמצעות הפונקציה
    שייבאתם מקובץ הפונקציות).

4.  שמרו את התוצאות בקובץ RDS

"9_report_results":

1.  ייבאו את קובץ הRDS שייצרתם וערכו את שמות העמודות כך שיתאימו לפורמט
    שמצויין בקובץ

2.  הפיקו את הקובץ באמצעות כפתור ה"Knit"

3.  הגשה: את שלושת קבצי הקוד + קובץ הדיווח שהופק על ידי Rmarkdown יש
    להעלות למודל תחת "יחידה 9 - קבצי סטודנטים".

בהצלחה

## הגשה

עברו על הקובץ וודאו שהגשתם את כל התרגילים ועניתם על כל השאלות

במידה וכל התשובות שלכם תקינות יש ללחוץ על הכפתור: Generate, להעתיק את
הטקסט שמופיע בחלון למטה ולהגישו במודל\
בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```
